# -*- coding: utf-8 -*-
"""
/***************************************************************************
 StalpiAssist
                                 A QGIS plugin
 Helps in assisting for Stalpi
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-11-29
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Ionela
        email                : ioneladumitra@yahoo.ro
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from pathlib import Path

from . import config

from datetime import datetime

import os
import colorsys
import random

from qgis.core import QgsProject, QgsDxfExport, QgsCoordinateTransformContext, QgsField # type: ignore

from PyQt5.QtGui import QColor # type: ignore
from PyQt5.QtWidgets import QMessageBox, QFileDialog, QAction, QInputDialog # type: ignore
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, QFile, QTextCodec, QVariant # type: ignore
from qgis.PyQt.QtGui import QIcon  # type: ignore
from qgis.core import ( # type: ignore
    QgsMessageLog,
    QgsProcessingFeedback,
    Qgis,
    QgsProcessingContext,
    QgsProject,
    QgsVectorLayer,
    QgsProcessing,
    QgsWkbTypes,
    QgsDxfExport,
    QgsVectorFileWriter,
    QgsCoordinateTransformContext,
    QgsSymbol,
    QgsRendererCategory,
    QgsCategorizedSymbolRenderer,
    QgsPalLayerSettings,
    QgsRectangle,
    QgsTextFormat,
    QgsVectorLayerSimpleLabeling,
    QgsTextBufferSettings,
    QgsCoordinateReferenceSystem,
    QgsMapSettings,
    QgsCoordinateTransform,
    QgsMarkerSymbol,
    QgsLineSymbol,
    QgsSingleSymbolRenderer,
    QgsFeature,
    QgsExpression,
    QgsExpressionContext,
    QgsExpressionContextUtils,
    QgsUnitTypes,
    QgsGeometry, 
    QgsSpatialIndex,
    QgsLineString,
    edit
)
from PyQt5.QtCore import QSize # type: ignore

import shutil

import processing  # type: ignore

import os
import os.path

from .resources import *

from .func.helper_functions import HelperBase, SHPProcessor

from .func.generate_xml import GenerateXMLDialog
from .func.generate_excel import GenerateExcelDialog
import pandas as pd


class StalpiAssist:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.pt_name = None
        self.iface = iface
        self.context = QgsProcessingContext()
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        self.helper = HelperBase()
        # self.register_functions()
        self.processor = None
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'StalpiAssist_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&StalpiAssist')
        
        self.layers = self.helper.get_layers()

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None


    @staticmethod
    def plugin_path(*args) -> Path:
        """ Return the path to the plugin root folder or file. """
        path = Path(__file__).resolve().parent
        for item in args:
            path = path.joinpath(item)
        return path


    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('StalpiAssist', message)


    def add_action(
        self,
        name,
        text,
        callback=None,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None,
        icon_path=None,
        shortcut=None,):
        
        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.setEnabled(enabled_flag)

        if callback is not None:
            action.triggered.connect(callback)
            action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)
            
        if shortcut is not None:
            action.setShortcut(shortcut)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action


    def initGui(self):
        self.toolbar = self.iface.addToolBar('StalpiAssist')
        self.toolbar.setObjectName('StalpiAssist')
        self.toolbar.setMovable(True)
        
        # Adding actions with default enabled flag set to False except "Fisier Destinatie"
        self.fisier_destinatie_action = self.add_action(
            "Fisier Destinatie",
            text=self.tr(u'Fisier Destinatie'),
            callback=self.set_base_dir,
            parent=self.iface.mainWindow(),
            icon_path= str(self.plugin_path('icons/folder.png')),
            enabled_flag=True
        )
        
        self.actions_to_enable = [
            self.add_action(
                "Separare poze dupa selectie",
                text=self.tr(u'Separare poze dupa selectie'),
                callback=self.separate_photos_by_selection,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/separate.png')),
                enabled_flag=False
            ),
            self.add_action(
                "Completare câmpuri",
                text=self.tr(u'Completare câmpuri'),
                callback=self.complete_fields,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/0.png')),
                enabled_flag=False
            ),
            self.add_action(
                "001_TRONSON_JT",
                text=self.tr(u'001_TRONSON_JT'),
                callback=self.run_tronson_model,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/1.png')),
                enabled_flag=False
            ),
            self.add_action(
                "002_BRANS_FIRI_GR",
                text=self.tr(u'002_BRANS_FIRI_GR'),
                callback=self.run_brans_model,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/2.png')),
                enabled_flag=False
            ),
            self.add_action(
                "003_STALP_JT",
                text=self.tr(u'003_STALP_JT'),
                callback=self.run_stalp_model,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/3.png')),
                enabled_flag=False
            ),
                self.add_action(
                "Copiere si redenumire poze",
                text=self.tr(u'Copiere si redenumire poze'),
                callback=self.copy_rename_pictures,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/photos.png')),
                enabled_flag=False
            ),
            self.add_action(
                "Redenumire cale server SFTP poze",
                text=self.tr(u'Redenumire cale server SFTP poze'),
                callback=self.rename_sftp_pictures,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/sftp.png')),
                enabled_flag=False
            ),
            self.add_action(
                "004_DESCHIDERI_JT",
                text=self.tr(u'004_DESCHIDERI_JT'),
                callback=self.run_deschideri_model,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/4.png')),
                enabled_flag=False
            ),
            self.add_action(
                "Generare linie ajutatoare",
                text=self.tr(u'Generare linie ajutatoare pentru offset'),
                callback=self.generate_helper_line,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/offset.png')),
                enabled_flag=False
            ),
            self.add_action(
                "003_TRONSOANE_DUBLE",
                text=self.tr(u'003_TRONSOANE_DUBLE'),
                callback=self.run_tronsoane_duble_model,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/5.png')),
                enabled_flag=False
            ),
            self.add_action(
                "Generare XML",
                text=self.tr(u'Generare XML'),
                callback=self.generate_xml,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/xml.png')),
                enabled_flag=False
            ),
            self.add_action(
                "Generare Machete",
                text=self.tr(u'Generare Machete'),
                callback=self.generare_machete,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/macheta.png')),
                enabled_flag=False
            ),
            self.add_action(
                "Generate Anexa",
                text=self.tr(u'Generate Anexa'),
                callback=self.generate_anexa,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/anexa.png')),
                enabled_flag=False
            ),
            self.add_action(
                "Export DXF",
                text=self.tr(u'Export DXF'),
                callback=self.export_dxf_kml,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/export.png')),
                enabled_flag=False
            ),
            self.add_action(
                "Măsoara lungime tronson",
                text=self.tr(u'Măsoara lungime tronson'),
                callback=self.change_length_tronson,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/measure.png')),
                enabled_flag=True 
            )
        ]
        
        self.toolbar.addSeparator()

        self.action_length = self.add_action(
            "Lungime PT",
            text=self.tr(u"Lungime TRONSON_JT: apasă pentru calcul"),
            callback=self.trigger_calc_length,
            parent=self.iface.mainWindow()
        )
        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(self.tr(u'&Stalpi Assist'), action)
            self.toolbar.removeAction(action)
        del self.toolbar
        
        
    def trigger_calc_length(self):
        layers = QgsProject.instance().mapLayersByName("TRONSON_JT")
        if layers:
            self.layer = layers[0]
            self.connectLayerSignals(self.layer)
            self.recalc_length()
        QgsProject.instance().layersAdded.connect(self.onLayersAdded)
        QgsProject.instance().readProject.connect(self.onProjectRead)

    def connectLayerSignals(self, layer):
        layer.featureAdded.connect(self.recalc_length)
        layer.featuresDeleted.connect(self.recalc_length)
        layer.geometryChanged.connect(self.recalc_length)
        layer.committedFeaturesAdded.connect(self.recalc_length)
        layer.committedFeaturesRemoved.connect(self.recalc_length)
        layer.committedGeometriesChanges.connect(self.recalc_length)
        layer.afterCommitChanges.connect(self.recalc_length)

    def onLayersAdded(self, layers):
        for layer in layers:
            if layer.name() == "TRONSON_JT":
                self.layer = layer
                self.connectLayerSignals(layer)
                self.recalc_length()

    def onProjectRead(self):
        layers = QgsProject.instance().mapLayersByName("TRONSON_JT")
        if layers:
            self.layer = layers[0]
            self.connectLayerSignals(self.layer)
            self.recalc_length()

    def recalc_length(self):
        length_with_overlap_m = 0.0
        total_union = None

        if not self.layer:
            return

        for feat in self.layer.getFeatures():
            geom = feat.geometry()
            if not geom or geom.isEmpty():
                continue

            length_with_overlap_m += geom.length()

            if total_union is None:
                total_union = geom
            else:
                total_union = total_union.combine(geom) 


        length_no_overlap_km = 0.0
        if total_union:
            length_no_overlap_km = total_union.length() / 1000.0

        length_with_overlap_km = length_with_overlap_m / 1000.0

        if self.action_length:
            display_text = self.tr(
                u"Lungime TRONSON_JT - Fără suprapuneri: {:.2f} km | Cu suprapuneri: {:.2f} km"
                .format(length_no_overlap_km, length_with_overlap_km)
            )
            self.action_length.setText(display_text)
        
    def get_layer_path(self, layer_name):
        """
        Get the full data source path of a layer by its name.

        Parameters:
            layer_name (str): The name of the layer in the QGIS project.

        Returns:
            str: The full data source path of the layer, including `|layername=`.
                Returns None if the layer is not found.
        """
        # Search for the layer by name in the current project
        layers = QgsProject.instance().mapLayersByName(layer_name)
        if not layers:
            QgsMessageLog.logMessage(f"Layer '{layer_name}' not found in the project.", "StalpiAssist", level=Qgis.Critical)
            return None
        
        # Get the first matching layer
        layer = layers[0]
        # Extract the data source path
        data_source = layer.dataProvider().dataSourceUri()
        
        # Append layername (important for GPKG files with multiple layers)
        if layer.storageType() == "GeoPackage" and "|layername=" not in data_source:
            data_source += f"|layername={layer.name()}"
        
        return data_source
    
    def get_layer_by_name(self, layer_name):
        """Retrieve a layer from the QGIS project by name."""
        layer = QgsProject.instance().mapLayersByName(layer_name)
        if layer:
            return layer[0]  # Return the first matching layer
        else:
            raise Exception(f"Layer '{layer_name}' not found in the project.")
    
    def set_base_dir(self):
        """Set base directory and update icons."""
        st_layer = self.get_layer_by_name("STALP_JT")
        br_layer = self.get_layer_by_name("BRANS_FIRI_GRPM_JT")
        tr_layer = self.get_layer_by_name("TRONSON_JT")
        linie_layer = self.get_layer_by_name("LINIE_JT")
        fb_layer = self.get_layer_by_name("FB pe C LES")
        
        missing_layers = []
        for layer in [st_layer, br_layer, tr_layer, linie_layer, fb_layer]:
            if not layer:
                missing_layers.append(layer.name())
                
        if missing_layers:
            QMessageBox.critical(None, "Eroare", f"Urmatoarele layere lipsesc: {', '.join(missing_layers)}")
            return
        
        self.helper.remove_diacritics()
        self.helper.replace_empty_values()
        self.helper.delete_id_bdi()
        
        is_valid = self.helper.check_obligatory_fields()
        if not is_valid:
            QMessageBox.critical(None, "Eroare", "Unele coloane obligatorii au valori nule. Verifica layer-ul rezultat si completeaza coloanele.")
            return
        
        base_dir = QFileDialog.getExistingDirectory(None, "Select Base Directory", "")
        if base_dir:
            self.base_dir = base_dir
            
            self.fisier_destinatie_action.setIcon(QIcon(str(self.plugin_path('icons/complete.png'))))
            
            for action in self.actions_to_enable:
                action.setEnabled(True)
                
            self.feedback = QgsProcessingFeedback()
            self.context.setProject(QgsProject.instance())
            
            existing_layer = QgsProject.instance().mapLayersByName("GRID_GEOID")
            
            if not existing_layer:
                template_file = self.plugin_path('func', 'templates', 'GRID_GEOID.gpkg')
                layer = QgsVectorLayer(f"{template_file}|layername=GRID_GEOID", "GRID_GEOID", "ogr")
                
                if layer.isValid():
                    QgsProject.instance().addMapLayer(layer)
                    
                    root = QgsProject.instance().layerTreeRoot()
                    layer_node = root.findLayer(layer.id())
                    if layer_node:
                        layer_node.setItemVisibilityChecked(False)
                else:
                    QgsMessageLog.logMessage("Failed to load GRID_GEOID layer.", "StalpiAssist", level=Qgis.Critical)
                    
                    
    def separate_photos_by_selection(self):
        '''
        based on a selection or a drawn polygon, get all features from poze and save them in new layers with the same name, saving them to self.base_dir
        '''
        
        poze_layer = QgsProject.instance().mapLayersByName("poze")
        
        if not poze_layer:
            QMessageBox.critical(None, "Eroare", f"Stratul 'poze' nu există în proiect. Asigură-te că stratul există și are denumirea corectă.")
            return

        poze = poze_layer[0]
        # The name we’ll look for/create
        polygon_layer_name = "poligon"

        polygon_layers = QgsProject.instance().mapLayersByName(polygon_layer_name)
        polygon_layer = polygon_layers[0] if polygon_layers else None

        if not polygon_layer or polygon_layer.featureCount() == 0:
            temp_crs = poze.crs().authid()
            temp_layer = QgsVectorLayer(
                f"Polygon?crs={temp_crs}", 
                polygon_layer_name, 
                "memory"
            )

            QgsProject.instance().addMapLayer(temp_layer)
            QMessageBox.information(None, "Poligon", "Deseneaza poligonul pe zona dorita si apoi apasa din nou pe buton.")
            
            # make layer editable, enable "add polygon feature" to start drawing immeately
            temp_layer.startEditing()
            self.iface.setActiveLayer(temp_layer)
            self.iface.actionAddFeature().trigger()
            return
            

        if polygon_layer.featureCount() != 1:
            QMessageBox.warning(
                None,
                "Poligon invalid",
                f"Layerul {polygon_layer_name} trebuie să conțină un singur poligon."
            )
            return

        polygon_feature = next(polygon_layer.getFeatures())
        polygon_geom = polygon_feature.geometry()
        

        layers_to_filter = {
            "poze": poze,
        }

        base_dir = self.base_dir
        if not os.path.exists(base_dir):
            os.makedirs(base_dir)

        root = QgsProject.instance().layerTreeRoot()
        group_name = f"Date_Filtrate_{polygon_layer_name}"
        new_group = root.addGroup(group_name)

        for layer_name, original_layer in layers_to_filter.items():
            geometry_type = QgsWkbTypes.displayString(original_layer.wkbType())
            crs = original_layer.crs().authid()

            # Create a temporary in-memory layer
            new_layer = QgsVectorLayer(f"{geometry_type}?crs={crs}", layer_name, "memory")
            new_layer_data = new_layer.dataProvider()
            new_layer_data.addAttributes(original_layer.fields())
            new_layer.updateFields()

            # Filter features intersecting polygon_geom and add them to the temporary layer
            matching_features = []
            for feature in original_layer.getFeatures():
                if feature.geometry() and feature.geometry().intersects(polygon_geom):
                    matching_features.append(QgsFeature(feature))
            new_layer_data.addFeatures(matching_features)
            new_layer.updateExtents()

            # Save the temporary layer to disk (GeoPackage)
            output_path = os.path.join(base_dir, f"{layer_name}.gpkg")
            QgsVectorFileWriter.writeAsVectorFormat(
                new_layer, output_path, "UTF-8", original_layer.crs(), "GPKG"
            )

            # Load the saved layer as the permanent layer
            permanent_layer = QgsVectorLayer(output_path, layer_name, "ogr")
            QgsProject.instance().addMapLayer(permanent_layer, False)
            new_group.addLayer(permanent_layer)
            
            if original_layer:
                orig_renderer = original_layer.renderer()
                if orig_renderer is not None:
                    permanent_layer.setRenderer(orig_renderer.clone())
                else:
                    QgsMessageLog.logMessage(f"Warning: No renderer found for {layer_name}.", level=Qgis.Warning)

                # Clone labeling if enabled and available
                if original_layer.labelsEnabled() and original_layer.labeling() is not None:
                    permanent_layer.setLabeling(original_layer.labeling().clone())
                    permanent_layer.setLabelsEnabled(True)

                permanent_layer.triggerRepaint()


        QMessageBox.information(None, "Succes", "Layerul filtrat a fost salvat cu succes.")
        # if polygon_layer:
        #     polygon_layer.commitChanges()
        #     QgsProject.instance().removeMapLayer(polygon_layer.id())

    def complete_fields(self):
        '''
        - Asks user for Judet and Denumire.
        - Completes the NR_CRT field for specified layers.
        - Looks up data in the correct sheet of bd.xlsx based on the selected Judet.
        - Populates fields in TRONSON_JT and STALP_JT layers based on the lookup.
        '''
        # Get active QGIS project
        project = QgsProject.instance()

        # Define Judet to Excel Sheet mapping
        judete_map = {
            "Buzău": "BZ",
            "Brăila": "BR",
            "Vrancea": "VR",
            "Prahova": "PH"
        }
        judete_list = list(judete_map.keys())

        # Prompt user for 'Județ' using a dropdown
        judet, ok = QInputDialog.getItem(None, "Selectează Județul", "Alege județul:", judete_list, 0, False)
        if not ok or not judet:
            return  # User cancelled

        # Get the corresponding sheet name and store it for other functions
        self.judet_sheet = judete_map[judet]

        # Prompt user for 'Denumire'
        denumire, ok = QInputDialog.getText(None, "Input Descriere BDI", f"Introduce Descrierea BDI pentru judetul {judet}:")
        if not ok or not denumire:
            return
        
        self.pt_name = denumire
        
        # Load the Excel template using the correct sheet for the selected county
        xlsx_path = self.plugin_path('func', 'templates', 'bd.xlsx')
        try:
            df = pd.read_excel(xlsx_path, sheet_name=self.judet_sheet)
        except Exception as e:
            QMessageBox.critical(None, "Eroare Fisier", f"Nu s-a putut citi foaia '{self.judet_sheet}' din 'bd.xlsx'.\nEroare: {e}")
            return
        
        # Search for the row where 'Descrierea BDI' matches the user's input
        match = df[df['Descrierea BDI'] == denumire]
        if match.empty:
            QMessageBox.critical(None, "Error", f"Nu a fost gasita o intrare pentru '{denumire}' in foaia '{self.judet_sheet}' a fisierului bd.xlsx")
            return
        
        # Extract relevant values from the matched row
        unit_log_int = match.iloc[0]['Unitate logistica de întretinere']
        s_unit_log = match.iloc[0]['Sectie unitate logistica']
        post_luc = match.iloc[0]['Post de lucru']
        sucursala = match.iloc[0]['Sucursala']

        # Helper function to assign sequential row numbers to NR_CRT field
        def assign_row_numbers(layer):
            layer.startEditing()
            for index, feat in enumerate(layer.getFeatures(), start=1):
                feat["NR_CRT"] = index
                layer.updateFeature(feat)
            layer.commitChanges()

        # Update TRONSON_JT layer
        tronson_layer = project.mapLayersByName("TRONSON_JT")[0]
        if tronson_layer:
            tronson_layer.startEditing()
            for feat in tronson_layer.getFeatures():
                feat["UNIT_LOG_INT"] = unit_log_int
                feat["S_UNIT_LOG"] = s_unit_log
                feat["POST_LUC"] = post_luc
                tronson_layer.updateFeature(feat)
            tronson_layer.commitChanges()
            assign_row_numbers(tronson_layer)

        # Update STALP_JT layer
        stalp_layer = project.mapLayersByName("STALP_JT")[0]
        if stalp_layer:
            stalp_layer.startEditing()
            for feat in stalp_layer.getFeatures():
                feat["DESC_DET"] = f"{sucursala}-{post_luc}"
                feat["TIP_ZONA_AMP"] = "Rural" if feat["TIP_ZONA_AMP"] in config.NULL_VALUES else feat["TIP_ZONA_AMP"]
                stalp_layer.updateFeature(feat)
            stalp_layer.commitChanges()
            assign_row_numbers(stalp_layer)

        # Update BRANS_FIRI_GRMP_JT layer
        brans_layer = project.mapLayersByName("BRANS_FIRI_GRPM_JT")[0]
        if brans_layer:
            assign_row_numbers(brans_layer)

        QMessageBox.information(None, "Success", "Fields completed successfully!")

    def apply_categorization(self, layer, field_name):
            # Apply categorization by a specific field to layer
            unique_values = layer.uniqueValues(layer.fields().lookupField(field_name))
            categories = []
            
            predefined_colors = [
                QColor(255, 0, 0), QColor(0, 255, 0), QColor(0, 0, 255),
                QColor(255, 255, 0), QColor(255, 165, 0), QColor(255, 20, 147),
                QColor(0, 255, 255), QColor(128, 0, 128), QColor(0, 128, 0),
                QColor(0, 0, 128), QColor(75, 0, 130), QColor(255, 105, 180)
            ]
            random.shuffle(predefined_colors)
            
            for i, value in enumerate(unique_values):
                if i >= len(predefined_colors):
                    break
                symbol = QgsSymbol.defaultSymbol(layer.geometryType())
                symbol.setColor(predefined_colors[i])
                symbol.setWidth(1.25)
                categories.append(QgsRendererCategory(value, symbol, str(value)))
            
            renderer = QgsCategorizedSymbolRenderer(field_name, categories)
            layer.setRenderer(renderer)
            layer.triggerRepaint()

    def run_tronson_model(self):
        params = {
            "linie_jt_introduse": self.get_layer_path("LINIE_JT"),
            "stalpi_desenati": self.get_layer_path("STALP_JT"),
            "tronson_desenat": self.get_layer_path("TRONSON_JT"),
            "tronson_xml_": QgsProcessing.TEMPORARY_OUTPUT
        }

        try:
            result = processing.run("model:001 TRONSON_JT", params)
            
            scratch_layer = result["tronson_xml_"]

            if isinstance(scratch_layer, QgsVectorLayer):
                # Save TRONSON_XML_
                scratch_layer.setName("TRONSON_XML_")
                QgsProject.instance().addMapLayer(scratch_layer)
                save_path = os.path.join(self.base_dir, "TRONSON_XML_.gpkg")

                options = QgsVectorFileWriter.SaveVectorOptions()
                options.driverName = "GPKG"
                options.fileEncoding = "UTF-8"

                error = QgsVectorFileWriter.writeAsVectorFormatV3(
                    scratch_layer, save_path, QgsCoordinateTransformContext(), options
                )

                if not error[0] == QgsVectorFileWriter.NoError:
                    QMessageBox.critical(self.iface.mainWindow(), "Save Error", f"Failed to save layer: {error}")

                # Duplicate the output layer as NO_OFFSET_TRONSON_XML_
                no_offset_layer = scratch_layer.clone()
                no_offset_layer.setName("NO_OFFSET_TRONSON_XML_")
                QgsProject.instance().addMapLayer(no_offset_layer)

                self.apply_categorization(scratch_layer, "ID_LOC")

            else:
                raise TypeError("Unexpected output type from processing.run")

            QMessageBox.information(self.iface.mainWindow(), "Model Completed", "001 TRONSON_JT model finished successfully!")

        except Exception as e:
            QMessageBox.critical(self.iface.mainWindow(), "Model Error", f"An error occurred: {str(e)}")

            

    def run_brans_model(self):
        """Run Brans model, using multiple expressions in the same context."""
        fb_layer = self.get_layer_by_name("FB pe C LES")
        if not fb_layer:
            QMessageBox.critical(None, "Error", "Layer 'FB pe C LES' not found.")
            return

        # 1. Prepare all your expressions once, outside the loop.
        exprs = {
            "ID_LOC": QgsExpression("""
                aggregate(
                    layer:='TRONSON_XML_',
                    aggregate:='array_agg',
                    expression:="ID_LOC",
                    filter:=intersects($geometry, geometry(@parent))
                )[0]
            """),
            "ID_PLC_BR": QgsExpression("""
                aggregate(
                layer:='TRONSON_XML_',
                aggregate:='array_agg',
                expression:="ID_LOC",
                filter:=intersects($geometry, geometry(@parent))
            )[0]
            """)
        }

        # 2. Create one context and load the project+layer scopes.
        context = QgsExpressionContext()
        context.appendScopes(
            QgsExpressionContextUtils.globalProjectLayerScopes(fb_layer)
        )

        fb_layer.startEditing()
        for idx, feat in enumerate(fb_layer.getFeatures(), start=1):
            # simple attributes you were already setting
            feat["NR_CRT"]          = idx + 1000
            feat["CLASS_ID"]        = 2003
            feat["DENUM"]           = f"FB {feat['STR']} {feat['NR_IMOB']}"
            feat["CLASS_ID_PLC_BR"] = 2003
            feat["SURSA_COORD"]     = 'Vectorizare in plan'
            feat["DATA_COORD"]      = datetime.now().strftime("%d.%m.%Y")

            # 3. Reset the context to this feature
            context.setFeature(feat)

            # 4. Loop through your expressions dict,
            #    evaluate and assign each result.
            for field_name, expression in exprs.items():
                val = expression.evaluate(context)
                if expression.hasEvalError():
                    raise RuntimeError(
                        f"Expression error for {field_name}: "
                        f"{expression.evalErrorString()}"
                    )
                feat[field_name] = val

            fb_layer.updateFeature(feat)

        if not fb_layer.commitChanges():
            fb_layer.rollBack()
            QMessageBox.critical(
                None, "Error",
                f"Failed to commit: {fb_layer.commitErrors()}"
            )
        
        # run model
        params = {
            "brans_firi_desenate": self.get_layer_path("BRANS_FIRI_GRPM_JT"),
            "fb_pe_c_les": self.get_layer_path("FB pe C LES"),
            "linie_jt_introduse": self.get_layer_path("LINIE_JT"),
            "bransament_xml_": QgsProcessing.TEMPORARY_OUTPUT,  # Scratch layer
            "grup_masura_xml_": QgsProcessing.TEMPORARY_OUTPUT,  # Scratch layer
            "firida_xml_": QgsProcessing.TEMPORARY_OUTPUT  # Scratch layer
        }

        try:
            # Run the processing model
            result = processing.run("model:002 BRANS_FIRI_GR", params)

            # Dictionary to store layer names and their permanent save paths
            layers_to_save = {
                "bransament_xml_": "BRANSAMENT_XML_.gpkg",
                "grup_masura_xml_": "GRUP_MASURA_XML_.gpkg",
                "firida_xml_": "FIRIDA_XML_.gpkg"
            }

            for key, filename in layers_to_save.items():
                scratch_layer = result[key]
                if isinstance(scratch_layer, QgsVectorLayer):
                    # Rename and add scratch layer to project
                    scratch_layer.setName(key.upper())  # Ensure consistency with naming
                    QgsProject.instance().addMapLayer(scratch_layer)

                    # Define save path
                    save_path = os.path.join(self.base_dir, filename)

                    # Save a permanent copy
                    options = QgsVectorFileWriter.SaveVectorOptions()
                    options.driverName = "GPKG"  # Saves as a GeoPackage
                    options.fileEncoding = "UTF-8"

                    error = QgsVectorFileWriter.writeAsVectorFormatV3(
                        scratch_layer, save_path, QgsCoordinateTransformContext(), options
                    )

                    if not error[0] == QgsVectorFileWriter.NoError:
                        QMessageBox.critical(
                            self.iface.mainWindow(), "Save Error", f"Failed to save layer {key}: {error}"
                        )
                else:
                    raise TypeError(f"Unexpected output type for {key} from processing.run")

            QMessageBox.information(self.iface.mainWindow(), "Model Completed", "002 BRANS_FIRI_GR model finished successfully!")

        except Exception as e:
            QMessageBox.critical(self.iface.mainWindow(), "Model Error", f"An error occurred: {str(e)}")
        

    def copy_rename_pictures(self):
        new_directory = QFileDialog.getExistingDirectory(None, "Select Directory to Copy Photos")

        if not new_directory:
            QgsMessageLog.logMessage("No directory selected.", "StalpiAssist", level=Qgis.Warning)

        os.makedirs(new_directory, exist_ok=True)

        layers = QgsProject.instance().mapLayersByName('STALP_XML_')

        if not layers:
            QgsMessageLog.logMessage("Layer 'STALP_XML_' not found in the project.", "StalpiAssist", level=Qgis.Critical)
            return

        layer = layers[0] 

        img_fields = ['IMG_FILE_1', 'IMG_FILE_2', 'IMG_FILE_3', 'IMG_FILE_4']
        new_name_fields = ['new_name_1', 'new_name_2', 'new_name_3', 'new_name_4']

        for feature in layer.getFeatures():
            for img_field, name_field in zip(img_fields, new_name_fields):
                img_path = feature[img_field]
                new_name = feature[name_field]

                if not img_path:
                    QgsMessageLog.logMessage(f"Warning: Missing image path for {name_field}. Skipping.", "StalpiAssist", level=Qgis.Critical)
                    return
                
                if not new_name:
                    QgsMessageLog.logMessage(f"Warning: Missing new name for {name_field}. Skipping.", "StalpiAssist", level=Qgis.Critical)
                    return

                if not os.path.exists(img_path):
                    QgsMessageLog.logMessage(f"Warning: Image path '{img_path}' does not exist. Skipping.", "StalpiAssist", level=Qgis.Critical)
                    return

                file_ext = os.path.splitext(img_path)[1]
                new_path = os.path.join(new_directory, new_name + file_ext)

                try:
                    shutil.copy(img_path, new_path)
                except Exception as e:
                    QgsMessageLog.logMessage(f"Error: Failed to copy image '{img_path}' to '{new_path}': {str(e)}", "StalpiAssist", level=Qgis.Critical)
                    return

        QMessageBox.information(None, "Success", "Photos copied and renamed successfully!")


    def rename_sftp_pictures(self):
        # Attempt to retrieve the layer
        layers = QgsProject.instance().mapLayersByName("STALP_XML_")
        if not layers:
            QgsMessageLog.logMessage("Error: Layer 'STALP_XML_' not found.", "StalpiAssist", Qgis.Critical)
            return
        layer = layers[0]

        # Prompt user for base text
        base_text, ok = QInputDialog.getText(None, "Enter Base Text", "Enter the base text for IMG_FILE fields:")
        if not ok or not base_text:
            QgsMessageLog.logMessage("Operation canceled or no base text entered.", "StalpiAssist", Qgis.Critical)
            return

        # Ensure the layer is editable
        if not layer.isEditable():
            layer.startEditing()

        # Define the fields to be updated
        img_fields = ["IMG_FILE_1", "IMG_FILE_2", "IMG_FILE_3", "IMG_FILE_4"]
        new_name_fields = ["new_name_1", "new_name_2", "new_name_3", "new_name_4"]

        # Create a mapping from field names to field indices
        field_indices = {field.name(): idx for idx, field in enumerate(layer.fields())}

        count_updated = 0
        for feature in layer.getFeatures():
            feature_id = feature.id()
            updates = {}

            for img_field, new_name_field in zip(img_fields, new_name_fields):
                # Check if the new_name_field exists in the feature
                if new_name_field not in feature.fields().names():
                    QgsMessageLog.logMessage(
                        f"Feature {feature_id}: Field '{new_name_field}' does not exist.",
                        "StalpiAssist",
                        Qgis.Critical
                    )
                    return

                new_name = feature[new_name_field]

                # Ensure the img_field exists in the layer
                if img_field in field_indices:
                    img_field_index = field_indices[img_field]
                    updates[img_field_index] = f"{base_text}/{new_name}.JPG"
                else:
                    QgsMessageLog.logMessage(
                        f"Feature {feature_id}: Field '{img_field}' not found in layer.",
                        "StalpiAssist",
                        Qgis.Critical
                    )
                    return

            if updates:
                # Apply updates to the feature
                for field_index, value in updates.items():
                    layer.changeAttributeValue(feature_id, field_index, value)
                count_updated += 1

        # Commit changes if any updates were made
        if count_updated > 0:
            if layer.commitChanges():
                QMessageBox.information(None, "Success", "IMG_FILE fields have been updated with the entered base text.")
            else:
                QMessageBox.critical(None, "Error", "Failed to save changes to the layer.")
                layer.rollBack()
        else:
            layer.rollBack()
            QMessageBox.warning(None, "No Changes", "No IMG_FILE fields were updated.")


    def run_stalp_model(self):
        """Run Stalp model with a progress window."""
        
        params = {
            "poze_geotag": self.get_layer_path("poze"),
            "stalp_in_lucru": self.get_layer_path("STALP_JT"),
            "stalp_xml_": QgsProcessing.TEMPORARY_OUTPUT  # Scratch layer
        }
        
        try:
            # Run the processing model
            result = processing.run("model:003 STALP JT generare", params)

            # Retrieve the scratch layer
            scratch_layer = result["stalp_xml_"]

            if isinstance(scratch_layer, QgsVectorLayer):
                # Rename and add scratch layer to project
                scratch_layer.setName("STALP_XML_")
                QgsProject.instance().addMapLayer(scratch_layer)

                # Define save path
                save_path = os.path.join(self.base_dir, "STALP_XML_.gpkg")

                # Save a permanent copy
                options = QgsVectorFileWriter.SaveVectorOptions()
                options.driverName = "GPKG"  # Saves as a GeoPackage
                options.fileEncoding = "UTF-8"

                error = QgsVectorFileWriter.writeAsVectorFormatV3(
                    scratch_layer, save_path, QgsCoordinateTransformContext(), options
                )

                if not error[0] == QgsVectorFileWriter.NoError:
                    QMessageBox.critical(
                        self.iface.mainWindow(), "Save Error", f"Failed to save layer STALP_XML_: {error}"
                    )
            else:
                raise TypeError("Unexpected output type for stalp_xml_ from processing.run")

            QMessageBox.information(self.iface.mainWindow(), "Model Completed", "003 STALP JT model finished successfully!")

        except Exception as e:
            QMessageBox.critical(self.iface.mainWindow(), "Model Error", f"An error occurred: {str(e)}")

    
    def run_deschideri_model(self):
        """Run Deschideri model with a progress window."""
        
        params = {
            "stalpi_desenati": self.get_layer_by_name("STALP_JT"),
            "tronson_jt": self.get_layer_by_name("TRONSON_JT"),
            "deschideri_xml_": QgsProcessing.TEMPORARY_OUTPUT,  # Scratch layer
            "scr_dwg": QgsProcessing.TEMPORARY_OUTPUT  # Scratch layer
        }
        
        try:
            # Run the processing model
            result = processing.run("model:004 DESCHIDERI JT", params)

            # Dictionary to store layers and their corresponding permanent file paths
            layers_to_save = {
                "deschideri_xml_": "DESCHIDERI_XML_.gpkg",
                "scr_dwg": "SCR_DWG.gpkg"
            }

            for key, filename in layers_to_save.items():
                scratch_layer = result[key]
                if isinstance(scratch_layer, QgsVectorLayer):
                    # Rename and add scratch layer to project
                    scratch_layer.setName(key.upper())
                    QgsProject.instance().addMapLayer(scratch_layer)

                    # Define save path
                    save_path = os.path.join(self.base_dir, filename)

                    # Save a permanent copy
                    options = QgsVectorFileWriter.SaveVectorOptions()
                    options.driverName = "GPKG"  # Saves as a GeoPackage
                    options.fileEncoding = "UTF-8"

                    error = QgsVectorFileWriter.writeAsVectorFormatV3(
                        scratch_layer, save_path, QgsCoordinateTransformContext(), options
                    )

                    if not error[0] == QgsVectorFileWriter.NoError:
                        QMessageBox.critical(
                            self.iface.mainWindow(), "Save Error", f"Failed to save layer {key}: {error}"
                        )
                else:
                    raise TypeError(f"Unexpected output type for {key} from processing.run")
                
        except Exception as e:
            QMessageBox.critical(self.iface.mainWindow(), "Model Error", f"An error occurred: {str(e)}")

        # Retrieve the SCR_DWG layer for .scr file export
        scr_dwg_layer = QgsProject.instance().mapLayersByName("SCR_DWG")[0]
        
        if not scr_dwg_layer.isValid():
            raise Exception("Failed to load the SCR_DWG layer.")
        
        # Extract SCR_STLP column data
        scr_stlp_data = [
            feature["SCR_STLP"] for feature in scr_dwg_layer.getFeatures() 
            if feature.isValid() and feature["SCR_STLP"] not in config.NULL_VALUES
]
        # Write to a .scr file in the "temp" subdirectory
        scr_file_path = self.helper.create_valid_output(self.base_dir, "SCR_STLP.scr", "temp")

        with open(scr_file_path, "w") as scr_file:
            scr_file.write("\n".join(scr_stlp_data))  # Join with newline without extra at the end

        QMessageBox.information(self.iface.mainWindow(), "Export Completed", f"SCR_STLP data exported to {scr_file_path} successfully!")

    def cleanup_temp_layers(self, layer_name: str):
        """Remove layers by name if present."""
        proj = QgsProject.instance()
        layers = proj.mapLayersByName(layer_name)
        if layers:
            proj.removeMapLayers([l.id() for l in layers])

    def _joinstyle_miter(self):
        """Best-effort retrieval of a MITER join style across QGIS versions."""
        for path in (
            (Qgis, "JoinStyle", "Miter"),
            (Qgis, "GeometryOperationJoinStyle", "Miter"),
            (Qgis, "MiterJoin", None),
            (Qgis, "JoinStyleMiter", None),
        ):
            obj, *names = path
            try:
                v = obj
                for n in names:
                    if n is None:
                        break
                    v = getattr(v, n)
                return v
            except Exception:
                continue
        # last resort
        try:
            return Qgis.JoinStyle.Miter
        except Exception:
            return 1

    def _m_to_mu_factor(self, layer):
        return QgsUnitTypes.fromUnitToUnitFactor(QgsUnitTypes.DistanceMeters, layer.crs().mapUnits())

    def _mu_to_m_factor(self, layer):
        f = self._m_to_mu_factor(layer)
        return 1.0 / f if f else 0.0

    # -------------------- NEW AND MUCH MORE ROBUST MERGE FUNCTION --------------------
    # This function replaces the old `_safe_unary_line_merge`.
    # It uses processing algorithms for a guaranteed snap-and-merge result.
    def _robust_merge_and_dissolve(self, geoms, cluster_id, snap_tolerance_mu, log_tag):
        """
        Robustly merges a list of line geometries by first snapping them together
        and then dissolving them into single, continuous lines.
        """
        if not geoms:
            return []

        # 1. Create a temporary layer from the geometries in this cluster
        temp_layer = QgsVectorLayer("LineString?crs=EPSG:3857", f"temp_cluster_{cluster_id}", "memory")
        pr = temp_layer.dataProvider()
        pr.addAttributes([QgsField("cluster", QVariant.Int)])
        temp_layer.updateFields()

        with edit(temp_layer):
            for geom in geoms:
                if geom and not geom.isEmpty():
                    feat = QgsFeature(temp_layer.fields())
                    feat.setGeometry(geom)
                    feat.setAttribute("cluster", 1) # Assign all to the same group for dissolving
                    pr.addFeature(feat)

        if temp_layer.featureCount() == 0:
            return []

        # 2. Snap geometries together to close small gaps
        try:
            snapped = processing.run("native:snapgeometries", {
                'INPUT': temp_layer,
                'REFERENCE_LAYER': temp_layer,
                'TOLERANCE': snap_tolerance_mu,
                'BEHAVIOR': 2,  # Snap to anchor and vertices
                'OUTPUT': 'memory:'
            })
            snapped_layer = snapped['OUTPUT']
        except Exception as e:
            QgsMessageLog.logMessage(f"  -> Cluster {cluster_id}: Snap algorithm failed: {e}. Skipping.", log_tag, Qgis.Critical)
            return []

        # 3. Dissolve the snapped geometries to merge them into single features
        try:
            dissolved = processing.run("native:dissolve", {
                'INPUT': snapped_layer,
                'FIELD': ['cluster'], # Dissolve all features together
                'OUTPUT': 'memory:'
            })
            dissolved_layer = dissolved['OUTPUT']
        except Exception as e:
            QgsMessageLog.logMessage(f"  -> Cluster {cluster_id}: Dissolve algorithm failed: {e}. Skipping.", log_tag, Qgis.Critical)
            return []

        # 4. Extract the final, merged geometries
        final_geoms = []
        for f in dissolved_layer.getFeatures():
            g = f.geometry()
            # The result of dissolve can be a MultiLineString, so we split it back to single lines
            if QgsWkbTypes.isMultiType(g.wkbType()):
                final_geoms.extend(g.asGeometryCollection())
            else:
                final_geoms.append(g)

        QgsMessageLog.logMessage(f"  -> Cluster {cluster_id}: Robustly merged {len(geoms)} segments into {len(final_geoms)} continuous lines.", log_tag, Qgis.Info)
        return final_geoms
    # ---------------------------------------------------------------------------------

    def _post_process_offset(self, geom: QgsGeometry) -> QgsGeometry:
        """
        Fixes disjointed offsets from acute concave angles by extending lines to their intersection.
        """
        # If the geometry is simple (not multipart), it's a valid offset, so return it as is.
        if not QgsWkbTypes.isMultiType(geom.wkbType()):
            return geom

        parts = geom.asGeometryCollection()
        # This logic is specifically for fixing the case where an offset breaks into two lines.
        if len(parts) != 2:
            return geom

        line1, line2 = parts[0], parts[1]

        # Calculate the intersection point of the two lines (as if they were infinite)
        intersection_point = line1.intersection(line2)

        # If they don't intersect (e.g., they are parallel), we can't fix it.
        if not intersection_point or intersection_point.isEmpty():
            return geom

        # Find the endpoints of the two lines that are "dangling" in the middle
        p1_start, p1_end = line1.vertexAt(0), line1.vertexAt(len(line1.vertices()) - 1)
        p2_start, p2_end = line2.vertexAt(0), line2.vertexAt(len(line2.vertices()) - 1)
        
        # Create a list of endpoints and their squared distances to find the two closest ones
        endpoints = [(p1_start, p2_start), (p1_start, p2_end), (p1_end, p2_start), (p1_end, p2_end)]
        distances = [p1.sqrDist(p2) for p1, p2 in endpoints]
        
        # Find the pair of endpoints that are closest to each other - these are the ones to replace
        min_dist_index = distances.index(min(distances))
        closest_pair = endpoints[min_dist_index]

        # Determine the "fixed" points that are not part of the dangling pair
        fixed_point1 = p1_end if closest_pair[0].equals(p1_start) else p1_start
        fixed_point2 = p2_end if closest_pair[1].equals(p2_start) else p2_start
        
        # Create a new, single, continuous line string from the fixed points to the intersection
        new_line = QgsLineString([fixed_point1, intersection_point.asPoint(), fixed_point2])
        
        return QgsGeometry(new_line)

    def generate_helper_line(self):
        """
        Generate helper offset lines along *overlapping* portions of a line layer.
        - Detects **partial** overlaps via self-intersection.
        - Clusters all touching/overlapping segments.
        - **Robustly snaps and dissolves** clusters into continuous lines.
        - Groups by unique overlap segment and counts **distinct original features**.
        - Offsets the **merged overlap segment** itself, spaced symmetrically with SHARP corners.
        """
        log_tag = "HelperLineDebug"
        QgsMessageLog.logMessage("--- Starting Helper Line Generation (v4 - Sharp Corners) ---", log_tag, Qgis.Info)

        # --- PARAMETERS ---
        original_source_layer_name = "TRONSON_JT"
        output_layer_name = "linie_aj"
        half_span_m = 3.0
        snap_tolerance_m = 0.01  # Snap features within 1cm of each other. CRUCIAL for gluing!
        n_segs = 1               # Use 1 for sharp corners, >1 for rounded corners.
        miter_limit = 5            # Controls how long sharp corners can get before being cut off.
        # ------------------

        proj = QgsProject.instance()

        self.cleanup_temp_layers(output_layer_name)

        src_list = proj.mapLayersByName(original_source_layer_name)
        if not src_list:
            QMessageBox.warning(None, "Eroare", f"Nu am găsit stratul „{original_source_layer_name}”.")
            return
        src_layer = src_list[0]
        
        m_to_mu = self._m_to_mu_factor(src_layer)
        mu_to_m = self._mu_to_m_factor(src_layer)
        snap_tolerance_mu = snap_tolerance_m * m_to_mu

        # Step 1: Prepare source layer (No changes here)
        drop_mz = processing.run("native:dropmzvalues", {"INPUT": src_layer, "OUTPUT": "memory:"})
        layer2d = drop_mz["OUTPUT"]
        srcid_field = "__srcfid__"
        with edit(layer2d):
            if srcid_field not in [f.name() for f in layer2d.fields()]:
                layer2d.addAttribute(QgsField(srcid_field, QVariant.LongLong))
                for f in layer2d.getFeatures():
                    layer2d.changeAttributeValue(f.id(), layer2d.fields().indexOf(srcid_field), int(f.id()))
                layer2d.updateFields()

        # Step 2: Self-intersection & Filtering (No changes here)
        try:
            inter = processing.run("native:intersection", { "INPUT": layer2d, "OVERLAY": layer2d, "INPUT_FIELDS": [srcid_field], "OVERLAY_FIELDS": [srcid_field], "OUTPUT": "memory:", })
            inter_layer = inter["OUTPUT"]
        except Exception as e:
            QMessageBox.critical(None, "Processing Error", f"Algoritmul 'Intersection' a eșuat.\n\nError: {e}")
            return
        fld_names = [f.name() for f in inter_layer.fields()]
        try:
            idx_a = fld_names.index(srcid_field)
            idx_b = [i for i, n in enumerate(fld_names) if n.startswith(srcid_field)][1]
        except IndexError:
            QMessageBox.critical(None, "Logic Error", "Could not find two source ID fields in intersection result.")
            return
        line_parts = []
        for f in inter_layer.getFeatures():
            g = f.geometry()
            if not g or g.isEmpty() or QgsWkbTypes.geometryType(g.wkbType()) != QgsWkbTypes.LineGeometry: continue
            a, b = f[idx_a], f[idx_b]
            if a is None or b is None or int(a) == int(b): continue
            parts = g.asGeometryCollection() if QgsWkbTypes.isMultiType(g.wkbType()) else [g]
            for p in parts:
                if p and not p.isEmpty() and QgsWkbTypes.geometryType(p.wkbType()) == QgsWkbTypes.LineGeometry:
                    line_parts.append((p, int(a), int(b)))
                    QgsMessageLog.logMessage(f"[Step 2] Found overlapping segment: {int(a)} <-> {int(b)}", log_tag, Qgis.Info)

        # Step 3: Clustering and Robust Merging (No changes here)
        if not line_parts:
            QMessageBox.information(None, "Info", f"Nu s-au găsit segmente suprapuse în „{original_source_layer_name}”.")
            return
        s_feats, s_data, s_index = [], [], QgsSpatialIndex()
        for i, (p, a, b) in enumerate(line_parts):
            feat = QgsFeature(i); feat.setGeometry(p); s_feats.append(feat)
            s_data.append({"geom": p, "participants": {a, b}}); s_index.insertFeature(feat)
        parent = list(range(len(s_feats)))
        def find_set(v):
            if v == parent[v]: return v
            parent[v] = find_set(parent[v]); return parent[v]
        def unite_sets(a, b):
            a, b = find_set(a), find_set(b)
            if a != b: parent[b] = a
        for i, feat in enumerate(s_feats):
            geom_i = feat.geometry()
            Pi = s_data[i]["participants"]  # frozenset({a,b})
            for j in s_index.intersects(geom_i.boundingBox()):
                if i >= j:
                    continue
                geom_j = s_feats[j].geometry()
                Pj = s_data[j]["participants"]
                if Pi != Pj:
                    continue  # keep A–B separate from C–D
                if geom_i.touches(geom_j) or geom_i.intersects(geom_j):
                    unite_sets(i, j)

        clusters = {}
        for i in range(len(s_feats)):
            root = find_set(i)
            if root not in clusters: clusters[root] = {"geoms": [], "participants": set()}
            clusters[root]["geoms"].append(s_data[i]["geom"])
            clusters[root]["participants"].update(s_data[i]["participants"])
        QgsMessageLog.logMessage(f"[Step 3] Grouped {len(line_parts)} segments into {len(clusters)} spatial clusters.", log_tag, Qgis.Info)
        groups = []
        for cluster_id, cluster_data in clusters.items():
            if len(cluster_data["participants"]) > 1:
                merged_geoms = self._robust_merge_and_dissolve(cluster_data["geoms"], cluster_id, snap_tolerance_mu, log_tag)
                for geom in merged_geoms:
                    if geom and not geom.isEmpty():
                        groups.append({"geom": geom, "participants": cluster_data["participants"]})
        QgsMessageLog.logMessage(f"[Step 3] Merged clusters into {len(groups)} final groups (with >1 participant).", log_tag, Qgis.Info)

        if not groups:
            QMessageBox.information(None, "Info", "Nu s-au găsit segmente suprapuse care să implice mai multe tronsoane diferite.")
            return

        # Step 4: Prepare destination layer (No changes here)
        dst = QgsVectorLayer(f"MultiLineString?crs={src_layer.crs().authid()}", output_layer_name, "memory")
        pr = dst.dataProvider()
        pr.addAttributes([QgsField("src_fid", QVariant.LongLong), QgsField("offset_m", QVariant.Double), QgsField("group_id", QVariant.LongLong), QgsField("n_group", QVariant.Int)])
        dst.updateFields()
        proj.addMapLayer(dst)

        # Step 5: Write offsets with SHARP corners
        created = 0
        js_miter = self._joinstyle_miter() # Use miter style
        half_span_mu = half_span_m * m_to_mu

        with edit(dst):
            for gid, rec in enumerate(groups, start=1):
                geom = rec["geom"]
                participants = sorted(list(rec["participants"]))
                n = len(participants)
                if n < 2: continue
                QgsMessageLog.logMessage(f"[Step 5] Processing group {gid}/{len(groups)} with {n} participants.", log_tag, Qgis.Info)
                
                offsets_mu = [0.0] if n == 1 else [(-half_span_mu + i * ((2 * half_span_mu) / (n - 1))) for i in range(n)]

                for src_id, dist_mu in zip(participants, offsets_mu):
                    try:
                        # Use n_segs=1 and the miter join style for sharp corners
                        off = geom.offsetCurve(dist_mu, n_segs, js_miter, miter_limit)
                        if not off or off.isEmpty(): continue
                        
                        # <<< ADD THIS LINE: Post-process the geometry to fix broken inner corners >>>
                        off = self._post_process_offset(off)

                        nf = QgsFeature(dst.fields())
                        nf.setGeometry(off)
                        nf.setAttributes([int(src_id), float(dist_mu * mu_to_m), int(gid), int(n)])
                        dst.addFeature(nf)
                        created += 1
                    except Exception as e:
                        QgsMessageLog.logMessage(f"  -> Offset CRASHED for participant {src_id}. Error: {e}", log_tag, Qgis.Critical)

        dst.updateExtents()
        QgsMessageLog.logMessage(f"--- Finished. Total features created: {created} ---", log_tag, Qgis.Info)

        if created == 0:
            QMessageBox.information(None, "Info", "Proces finalizat, dar nu au fost generate linii-ajutor. Verificați panoul de mesaje (Log Messages) pentru detalii.")
        else:
            QMessageBox.information(None, "Gata", f"Am generat {created} linii-ajutor în „{output_layer_name}” (fan ±{half_span_m} m).")






    def run_tronsoane_duble_model(self):
        """Run TRONSOANE DUBLE ACTUALIZARE model with a scratch layer and saved copy."""
        
        params = {
            "tronson_aranjat": self.get_layer_by_name("TRONSON_XML_"),
            "tronson_predare_xml": QgsProcessing.TEMPORARY_OUTPUT  # Scratch layer
        }
        
        try:
            # Run the processing model
            result = processing.run("model:TRONSOANE DUBLE ACTUALIZARE", params)

            # Retrieve the scratch layer
            scratch_layer = result["tronson_predare_xml"]

            if isinstance(scratch_layer, QgsVectorLayer):
                # Rename and add scratch layer to project
                scratch_layer.setName("TRONSON_predare_xml")
                QgsProject.instance().addMapLayer(scratch_layer)

                # Define save path
                save_path = os.path.join(self.base_dir, "TRONSON_predare_xml.gpkg")

                # Save a permanent copy
                options = QgsVectorFileWriter.SaveVectorOptions()
                options.driverName = "GPKG"  # Saves as a GeoPackage
                options.fileEncoding = "UTF-8"

                error = QgsVectorFileWriter.writeAsVectorFormatV3(
                    scratch_layer, save_path, QgsCoordinateTransformContext(), options
                )

                if not error[0] == QgsVectorFileWriter.NoError:
                    QMessageBox.critical(
                        self.iface.mainWindow(), "Save Error", f"Failed to save layer TRONSON_predare_xml: {error}"
                    )
            else:
                raise TypeError("Unexpected output type for tronson_predare_xml from processing.run")

            QMessageBox.information(self.iface.mainWindow(), "Model Completed", "TRONSOANE DUBLE ACTUALIZARE model finished successfully!")

        except Exception as e:
            QgsMessageLog.logMessage(f"Error in TRONSOANE DUBLE ACTUALIZARE model: {str(e)}", "StalpiAssist", level=Qgis.Critical)
            QMessageBox.critical(self.iface.mainWindow(), "Model Error", f"An error occurred: {str(e)}")

    def generate_xml(self):
        self.process_layers(self.layers)
        dialog = GenerateXMLDialog(self.base_dir)  # Create an instance of your dialog
        dialog.exec_()  # Properly call exec_ on the instance
        
    def generate_anexa(self):
        self.process_layers(self.layers)
        dialog = GenerateExcelDialog(self.base_dir, self.judet_sheet)  # Create an instance of your dialog
        dialog.exec_()  # Properly call exec_ on the instance
        
    def generare_machete(self):
        try: 
            xls1_params = {
                'linie': self.get_layer_by_name('LINIE_JT'),
                'stalp_xml_': self.get_layer_by_name('STALP_XML_'),
                'tronson_aranjat_': self.get_layer_by_name('TRONSON_predare_xml'),
                'tronson_xml_': self.get_layer_by_name('TRONSON_XML_'),
                'tronson_before_offset': self.get_layer_by_name('NO_OFFSET_TRONSON_XML_'),
                'aux_tr': self.helper.create_valid_output(self.base_dir, "AUX_tr.gpkg", "machete"),
                'linie_macheta': self.helper.create_valid_output(self.base_dir, "LINIE_MACHETA.gpkg", "machete"),
                'stalpi_macheta': self.helper.create_valid_output(self.base_dir, "STALPI MACHETA.gpkg", "machete"),
                'tronson_macheta': self.helper.create_valid_output(self.base_dir, "TRONSON MACHETA.gpkg", "machete")
            }

            # Run XLS_1 model
            processing.run('model:005 GENERARE MACHETE XLS_1', xls1_params)

            # Add resulting layers to project
            self.helper.add_layer_to_project(xls1_params['aux_tr'])
            self.helper.add_layer_to_project(xls1_params['linie_macheta'])
            self.helper.add_layer_to_project(xls1_params['stalpi_macheta'])
            self.helper.add_layer_to_project(xls1_params['tronson_macheta'])

        except Exception as e:
            QMessageBox.critical(self.iface.mainWindow(), "XLS_1 Model Error", f"An error occurred: {str(e)}")
            return  # Stop execution if XLS_1 fails

        try:
            xls2_params = {
                'bransament_xml_': self.get_layer_by_name('BRANSAMENT_XML_'),
                'deschideri_xml': self.get_layer_by_name('DESCHIDERI_XML_'),
                'firida_xml_': self.get_layer_by_name('FIRIDA_XML_'),
                'grup_masura_xml_': self.get_layer_by_name('GRUP_MASURA_XML_'),
                'linia_jt': self.get_layer_by_name('LINIE_JT'),
                'firida_macheta': self.helper.create_valid_output(self.base_dir, "FIRIDA MACHETA.gpkg", "machete"),
                'grup_masura_macheta': self.helper.create_valid_output(self.base_dir, "GRUP MASURA MACHETA.gpkg", "machete"),
                'deschideri_macheta': self.helper.create_valid_output(self.base_dir, "DESCHIDERI MACHETA.gpkg", "machete"),
                'bransamente_macheta': self.helper.create_valid_output(self.base_dir, "BRANSAMENTE MACHETA.gpkg", "machete")
            }

            # Run XLS_2 model
            processing.run('model:006 GENERARE MACHETE XLS_2', xls2_params)

            # Add resulting layers to project
            self.helper.add_layer_to_project(xls2_params['firida_macheta'])
            self.helper.add_layer_to_project(xls2_params['grup_masura_macheta'])
            self.helper.add_layer_to_project(xls2_params['deschideri_macheta'])
            self.helper.add_layer_to_project(xls2_params['bransamente_macheta'])

        except Exception as e:
            QMessageBox.critical(self.iface.mainWindow(), "XLS_2 Model Error", f"An error occurred: {str(e)}")
        
        QMessageBox.information(self.iface.mainWindow(), "Model Completed", "Generare Machete models finished successfully!")    
        
    def process_layers(self, layers):
        if not self.processor:
            try:
                self.processor = SHPProcessor(layers, self.judet_sheet)
            except Exception as e:
                return
        
        try:
            current_layers = self.helper.get_layers()
        except Exception as e:
            return
        
        if current_layers != layers:
            self.processor = None
            
            try:
                self.processor = SHPProcessor(current_layers, self.judet_sheet)
            except Exception as e:
                return
        else:
            return
        
    def export_dxf_kml(self):
        self.stylize_layers()

    def stylize_layers(self):
        layers = [
            "FIRIDA MACHETA", 
            "BRANSAMENTE MACHETA", 
            "STALPI MACHETA", 
            "TRONSON MACHETA"
        ]

        # colors: red, green, blue, yellow, pink, cyan, purple, green, blue
        bright_colors = [
            "#FF0000", "#00FF00", "#0000FF", "#FFFF00",
            "#00FFFF", "#FFA500", "#8A2BE2", "#DC143C"
        ]

        if len(layers) > len(bright_colors):
            bright_colors = [
                "#%02x%02x%02x" % (
                    int(255 * r), int(255 * g), int(255 * b)
                )
                for r, g, b in [
                    colorsys.hsv_to_rgb(i / len(layers), 1, 1) 
                    for i in range(len(layers))
                ]
            ]
        unique_colors = random.sample(bright_colors, len(layers))

        project = QgsProject.instance()

        for i, layer_name in enumerate(layers):
            matching_layers = project.mapLayersByName(layer_name)
            if not matching_layers:
                continue
            layer = matching_layers[0]

            color = QColor(unique_colors[i])

            settings = QgsPalLayerSettings()
            
            settings.fieldName = "Descrierea BDI"
                
            settings.enabled = True

            text_format = QgsTextFormat()
            text_format.setSize(50)
            text_format.setColor(color)

            buffer = QgsTextBufferSettings()
            buffer.setEnabled(True)
            buffer.setSize(1)
            buffer.setColor(QColor("black"))
            text_format.setBuffer(buffer)

            settings.setFormat(text_format)

            if layer.geometryType() == QgsWkbTypes.LineGeometry:
                settings.placement = QgsPalLayerSettings.Curved
                settings.isObstacle = False

            labeling = QgsVectorLayerSimpleLabeling(settings)
            layer.setLabeling(labeling)
            layer.setLabelsEnabled(True)

            layer.setCustomProperty("labeling", "pal")
            project.layerTreeRoot().findLayer(layer.id()).setCustomProperty("labeling", "pal")
            
            if layer_name == "TRONSON MACHETA":
                self.apply_categorization(layer, "ID_Locatia")
                continue

            if layer_name == "FIRIDA MACHETA":
                symbol = QgsMarkerSymbol.createSimple({
                    'name': 'triangle', 
                    'size': '3',
                    'color': '#0000FF'
                    })

                renderer = layer.renderer()
                if renderer is None or renderer.type() != 'singleSymbol':
                    renderer = QgsSingleSymbolRenderer(symbol)
                else:
                    renderer.setSymbol(symbol)
                layer.setRenderer(renderer)
                
            elif layer_name == "STALPI MACHETA":
                field_name = "Denumire"
                categories = []

                green_dot_symbol = QgsMarkerSymbol.createSimple({
                    'name': 'circle', 
                    'size': '3', 
                    'color': '#00FF00'
                })
                cat_other = QgsRendererCategory(
                    None,
                    green_dot_symbol,
                    'stp'
                )
                categories.append(cat_other)

                cat_renderer = QgsCategorizedSymbolRenderer(field_name, categories)
                layer.setRenderer(cat_renderer)
            
            elif layer_name in ["BRANSAMENTE MACHETA", "TRONSON MACHETA"]:
                if layer.geometryType() == QgsWkbTypes.LineGeometry:
                    thick_line = QgsLineSymbol.createSimple({
                        'width': '0.6',
                        'color': '#FF8000'
                    })
                    renderer = layer.renderer()
                    if renderer is None or renderer.type() != 'singleSymbol':
                        renderer = QgsSingleSymbolRenderer(thick_line)
                    else:
                        renderer.setSymbol(thick_line)
                    layer.setRenderer(renderer)

            layer.setCustomProperty("labeling/needsUpdate", True)
            layer.triggerRepaint()
            
        self.iface.mapCanvas().refreshAllLayers()
        self.iface.mapCanvas().refresh()
        self.iface.mapCanvas().update()
        QMessageBox.information(self.iface.mainWindow(), "Layer Styling", "Layers styled successfully!")

        self.export_to_dxf()



    def export_to_dxf(self):
        output_path = os.path.join(self.base_dir, "export.dxf")
        layer_names = ["FIRIDA MACHETA", "BRANSAMENTE MACHETA", "STALPI MACHETA", "TRONSON MACHETA"]

        # Collect only the layers you want
        candidate_layers = QgsProject.instance().mapLayers().values()
        layers_for_export = [layer for layer in candidate_layers if layer.name() in layer_names]

        if not layers_for_export:
            QMessageBox.critical(self.iface.mainWindow(), "StalpiAssist", "No layers found for export.")
            return

        # Make an empty extent
        extent = QgsRectangle()
        extent.setMinimal()

        # We want to ensure all extents are combined in the destination CRS
        dest_crs = QgsCoordinateReferenceSystem("EPSG:3844")
        for layer in layers_for_export:
            layer_extent = layer.extent()
            if layer_extent.isEmpty():
                continue

            # If the layer has a different CRS, transform its bounding box
            if layer.crs() != dest_crs:
                try:
                    xform = QgsCoordinateTransform(layer.crs(), dest_crs, QgsProject.instance())
                    layer_extent_3844 = xform.transformBoundingBox(layer_extent)
                    extent.combineExtentWith(layer_extent_3844)
                except Exception as e:
                    QgsMessageLog.logMessage(
                        f"Error transforming extent for layer {layer.name()}: {str(e)}",
                        "DXF Export",
                        Qgis.Critical
                    )
                    return
            else:
                extent.combineExtentWith(layer_extent)

        if extent.isEmpty():
            QgsMessageLog.logMessage("Computed extent is empty. Export aborted.", "DXF Export", Qgis.Critical)
            return

        # Prepare map settings
        settings = QgsMapSettings()
        settings.setOutputSize(QSize(8000, 8000))
        settings.setFlag(QgsMapSettings.DrawLabeling, True)
        settings.setFlag(QgsMapSettings.UseAdvancedEffects, True)
        settings.setFlag(QgsMapSettings.ForceVectorOutput, True)
        settings.setFlag(QgsMapSettings.Antialiasing, True)
        # settings.setCrsTransformEnabled(True)

        settings.setLayers(layers_for_export)
        settings.setExtent(extent)

        # Configure DXF export
        dxf_export = QgsDxfExport()
        dxf_export.setMapSettings(settings)
        dxf_export.setSymbologyScale(50)
        dxf_export.setSymbologyExport(Qgis.FeatureSymbologyExport.SymbolLayerSymbology)
        dxf_export.setLayerTitleAsName(1)
        dxf_export.setDestinationCrs(dest_crs)
        dxf_export.setExtent(extent)
        dxf_export.setFlags(QgsDxfExport.FlagNoMText)

        # Add layers for export
        dxf_export.addLayers([QgsDxfExport.DxfLayer(lyr) for lyr in layers_for_export])

        # Open DXF file for writing
        file = QFile(output_path)
        if not file.open(QFile.WriteOnly | QFile.Text):
            QgsMessageLog.logMessage(f"Failed to open file {output_path} for writing.", "DXF Export", Qgis.Critical)
            QMessageBox.critical(self.iface.mainWindow(), "DXF Export", f"Failed to open file {output_path} for writing.")
            return

        # Use UTF-8 encoding
        encoding = QTextCodec.codecForName("UTF-8").name().data().decode("utf-8")
        success = dxf_export.writeToFile(file, encoding)

        file.close()

        QMessageBox.information(self.iface.mainWindow(), "DXF Export",
        f"DXF file exported successfully at {output_path}"
        )


    def export_to_kml(self):
        output_directory = self.base_dir
        layers_to_export = [
            "FIRIDA MACHETA", "BRANSAMENTE MACHETA", "STALPI MACHETA", "TRONSON MACHETA"
        ]
        
        # Define colors for layers
        colors = ["ff0000ff", "ffff0000", "ff00ff00", "ff00ffff", "ffff00ff", "ffffa500", "ffffff00"]  # KML uses AABBGGRR format
        
        project = QgsProject.instance()
        
        # Export each layer separately as KML
        for i, layer_name in enumerate(layers_to_export):
            layers = project.mapLayersByName(layer_name)
            if not layers:
                QgsMessageLog.logMessage(f"Layer '{layer_name}' not found in the project.", "StalpiAssist", level=Qgis.Critical)
                continue  # Skip to the next layer if not found
            layer = layers[0]
            
            # Export to KML with name field "Descrierea BDI"
            kml_filename = os.path.join(output_directory, f"{layer_name}.kml")
            options = QgsVectorFileWriter.SaveVectorOptions()
            options.driverName = "KML"
            options.fileEncoding = "utf-8"
            options.onlySelectedFeatures = False
            options.layerName = layer_name
            options.layerOptions = [f'NameField=Descrierea BDI']  # Set the NameField to "Descrierea BDI"
            transform_context = QgsProject.instance().transformContext()
            error = QgsVectorFileWriter.writeAsVectorFormatV3(layer, kml_filename, transform_context, options)
            if error[0] == QgsVectorFileWriter.NoError:
                QMessageBox.information(self.iface.mainWindow(), "KMZ Export", f"{layer_name} exported successfully as KML.")
            else:
                QMessageBox.critical(self.iface.mainWindow(), "KMZ Export", f"Failed to export {layer_name} as KML: {error}")
        
        # Modify KML files for styling
        for kml_file in os.listdir(output_directory):
            if kml_file.endswith(".kml"):
                kml_path = os.path.join(output_directory, kml_file)
                with open(kml_path, "r", encoding="utf-8") as file:
                    kml_content = file.read()
                
                # Modify text size and color
                text_size = "<LabelStyle><scale>2</scale></LabelStyle>"
                
                color_tag = f"<color>{colors[i % len(colors)]}</color>"
                
                kml_content = kml_content.replace("<LabelStyle>", f"<LabelStyle>{text_size}").replace("<IconStyle>", f"<IconStyle>{color_tag}")
                
                # Special pin for "STP. 0" in "STALPI MACHETA"
                if "STALPI MACHETA" in kml_file:
                    kml_content = kml_content.replace("STP. 0", "<Style><IconStyle><scale>1.5</scale></IconStyle></Style>")
                
                with open(kml_path, "w", encoding="utf-8") as file:
                    file.write(kml_content)
                    
        kmz_filename = os.path.join(output_directory, "merged_export.kmz")
        os.system(f"zip -j {kmz_filename} {output_directory}/*.kml")
        QMessageBox.information(self.iface.mainWindow(), "KMZ Export", f"KMZ file exported successfully at {kmz_filename}")

    def change_length_tronson(self):
        """Prompt for a percentage and update LUNG_TR in every tronson layer."""

        names   = ("DESCHIDERI_XML_", "DESCHIDERI MACHETA")
        layers  = [l[0] for n in names if (l := QgsProject.instance().mapLayersByName(n))]
        if not layers:
            QMessageBox.warning(self.iface.mainWindow(), "StalpiAssist",
                                "Nu există niciun strat DESCHIDERI* în proiect.")
            return

        pct, ok = QInputDialog.getDouble(self.iface.mainWindow(),
                                        "Procentul de adăugare la lungime (%)",
                                        "Introdu procentul:",
                                        value=30.0, decimals=2, min=-100.0)
        if not ok:
            return

        factor   = 1 + pct/100.0
        expr_txt = f"format_number((length($geometry)/1000) * {factor}, 3)"
        
        for lyr in layers:
            fld = "LUNG" if lyr.name() != "DESCHIDERI MACHETA" else "Lungime (m)"
            if fld not in {f.name() for f in lyr.fields()}:
                lyr.dataProvider().addAttributes([QgsField(fld, QVariant.Double, len=10, prec=3)])
                lyr.updateFields()

            ctx  = QgsExpressionContext()
            ctx.appendScopes(QgsExpressionContextUtils.globalProjectLayerScopes(lyr))

            expr = QgsExpression(expr_txt)
            if expr.hasParserError():
                QMessageBox.critical(self.iface.mainWindow(), "Eroare expresie",
                                    f"Expresia nu este validă: {expr.parserErrorString()}")
                return

            idx  = lyr.fields().indexOf(fld)
            count_updates = 0

            lyr.startEditing()
            for ft in lyr.getFeatures():
                ctx.setFeature(ft)
                val = expr.evaluate(ctx)
                if expr.hasEvalError():
                    lyr.rollBack()
                    QMessageBox.critical(self.iface.mainWindow(), "Eroare evaluare",
                                        f"Eroare la feature {ft.id()}: {expr.evalErrorString()}")
                    return
                lyr.changeAttributeValue(ft.id(), idx, val)
                count_updates += 1

            if not lyr.commitChanges():
                QMessageBox.critical(self.iface.mainWindow(),
                                    "Eroare la commit",
                                    f"{lyr.name()}: {lyr.commitErrors()}")
                return

            QgsMessageLog.logMessage(f"{lyr.name()}: {count_updates} rânduri actualizate.",
                                    "StalpiAssist", Qgis.Info)

        QMessageBox.information(self.iface.mainWindow(), "Succes",
                                f"S-au recalculat lungimile cu factor {factor:.2f} în {len(layers)} straturi.")
        