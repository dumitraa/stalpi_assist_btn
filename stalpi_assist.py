# -*- coding: utf-8 -*-
"""
/***************************************************************************
 StalpiAssist
                                 A QGIS plugin
 Helps in assisting for Stalpi
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-11-29
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Ionela
        email                : ioneladumitra@yahoo.ro
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from pathlib import Path

from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication  # type: ignore
from qgis.PyQt.QtGui import QIcon  # type: ignore
from qgis.PyQt.QtWidgets import QAction, QFileDialog, QMessageBox  # type: ignore

from qgis.core import ( # type: ignore
    QgsMessageLog, 
    QgsProcessingFeedback, 
    Qgis, 
    QgsProcessingContext, 
    QgsProject, 
    QgsVectorLayer, 
    QgsProcessing, 
    QgsGeometry, 
    QgsWkbTypes, 
    QgsVectorFileWriter, 
    QgsCoordinateTransformContext, 
    register_function
)

import processing  # type: ignore

import os
import os.path

from .resources import *

from .func.helper_functions import HelperBase, SHPProcessor

from .func.generate_xml import GenerateXMLDialog
from .func.generate_excel import GenerateExcelDialog


class StalpiAssist:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        self.context = QgsProcessingContext()
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        self.helper = HelperBase()
        # self.register_functions()
        self.processor = None
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'StalpiAssist_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&StalpiAssist')
        
        self.layers = self.helper.get_layers()

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None


    @staticmethod
    def plugin_path(*args) -> Path:
        """ Return the path to the plugin root folder or file. """
        path = Path(__file__).resolve().parent
        for item in args:
            path = path.joinpath(item)
        return path


    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('StalpiAssist', message)


    def add_action(
        self,
        name,
        text,
        callback=None,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None,
        icon_path=None,
        shortcut=None,):
        
        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.setEnabled(enabled_flag)

        if callback is not None:
            action.triggered.connect(callback)
            action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)
            
        if shortcut is not None:
            action.setShortcut(shortcut)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action


    def initGui(self):

        self.toolbar = self.iface.addToolBar('StalpiAssist')
        self.toolbar.setObjectName('StalpiAssist')
        self.toolbar.setMovable(True)
        
        # Adding actions with default enabled flag set to False except "Fisier Destinatie"
        self.fisier_destinatie_action = self.add_action(
            "Fisier Destinatie",
            text=self.tr(u'Fisier Destinatie'),
            callback=self.set_base_dir,
            parent=self.iface.mainWindow(),
            icon_path= str(self.plugin_path('icons/folder.png')),
            enabled_flag=True
        )
        
        self.actions_to_enable = [
            self.add_action(
                "001_TRONSON_JT",
                text=self.tr(u'001_TRONSON_JT'),
                callback=self.run_tronson_model,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/1.png')),
                enabled_flag=False
            ),
            self.add_action(
                "002_BRANS_FIRI_GR",
                text=self.tr(u'002_BRANS_FIRI_GR'),
                callback=self.run_brans_model,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/2.png')),
                enabled_flag=False
            ),
            self.add_action(
                "003_STALP_JT",
                text=self.tr(u'003_STALP_JT'),
                callback=self.run_stalp_model,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/3.png')),
                enabled_flag=False
            ),
            self.add_action(
                "004_DESCHIDERI_JT",
                text=self.tr(u'004_DESCHIDERI_JT'),
                callback=self.run_deschideri_model,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/4.png')),
                enabled_flag=False
            ),
            self.add_action(
                "003_TRONSOANE_DUBLE",
                text=self.tr(u'003_TRONSOANE_DUBLE'),
                callback=self.run_tronsoane_duble_model,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/5.png')),
                enabled_flag=False
            ),
            self.add_action(
                "Generare Excel + XML",
                text=self.tr(u'Generare Excel + XML'),
                callback=self.generate_xml,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/xml.png')),
                enabled_flag=False
            ),
            self.add_action(
                "Generare Machete",
                text=self.tr(u'Generare Machete'),
                callback=self.generare_machete,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/macheta.png')),
                enabled_flag=False
            ),
            self.add_action(
                "Generate Anexa",
                text=self.tr(u'Generate Anexa'),
                callback=self.generate_anexa,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/anexa.png')),
                enabled_flag=False
            )
        ]
        
        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(self.tr(u'&Stalpi Assist'), action)
            self.toolbar.removeAction(action)
        del self.toolbar
        
    def register_functions(self):
        def round_wkt_coordinates(values, feature=None, parent=None, context=None):
            def format_point(point):
                return f"{round(point.x(), 4):.4f} {round(point.y(), 4):.4f}"

            geometry = values[0]  # Get the geometry from the input
            if isinstance(geometry, QgsGeometry):
                if geometry.isMultipart():
                    if geometry.type() == QgsWkbTypes.LineGeometry:
                        parts = [
                            "(" + ", ".join(format_point(point) for point in line) + ")"
                            for line in geometry.asMultiPolyline()
                        ]
                        wkt = f"MULTILINESTRING ({', '.join(parts)})"
                    else:
                        wkt = geometry.asWkt()  # For other geometry types
                else:
                    if geometry.type() == QgsWkbTypes.LineGeometry:
                        points = ", ".join(format_point(point) for point in geometry.asPolyline())
                        wkt = f"LINESTRING ({points})"
                    else:
                        wkt = geometry.asWkt()  # For other geometry types
                return wkt
            return None  # Return None if input is invalid

        register_function(
            round_wkt_coordinates,
            group="Custom",
            usesgeometry=True,
            params_as_list=True,
            helpText="Rounds WKT geometry coordinates to a given precision."
        )
        
    def get_layer_path(self, layer_name):
        """
        Get the full data source path of a layer by its name.

        Parameters:
            layer_name (str): The name of the layer in the QGIS project.

        Returns:
            str: The full data source path of the layer, including `|layername=`.
                Returns None if the layer is not found.
        """
        # Search for the layer by name in the current project
        layers = QgsProject.instance().mapLayersByName(layer_name)
        if not layers:
            QgsMessageLog.logMessage(f"Layer '{layer_name}' not found in the project.", "StalpiAssist", level=Qgis.Warning)
            return None
        
        # Get the first matching layer
        layer = layers[0]
        # Extract the data source path
        data_source = layer.dataProvider().dataSourceUri()
        
        # Append layername (important for GPKG files with multiple layers)
        if layer.storageType() == "GeoPackage" and "|layername=" not in data_source:
            data_source += f"|layername={layer.name()}"
        
        return data_source
    
    def get_layer_by_name(self, layer_name):
        """Retrieve a layer from the QGIS project by name."""
        layer = QgsProject.instance().mapLayersByName(layer_name)
        if layer:
            return layer[0]  # Return the first matching layer
        else:
            raise Exception(f"Layer '{layer_name}' not found in the project.")
    
    def set_base_dir(self):
        """Set base directory and update icons."""
        base_dir = QFileDialog.getExistingDirectory(None, "Select Base Directory", "")
        if base_dir:
            self.base_dir = base_dir  # Set the base directory here directly
            # Update the icon for Fisier Destinatie to complete.png
            self.fisier_destinatie_action.setIcon(QIcon(str(self.plugin_path('icons/complete.png'))))
            # Enable all other actions
            for action in self.actions_to_enable:
                action.setEnabled(True)
                
            self.feedback = QgsProcessingFeedback()
            self.context.setProject(QgsProject.instance())
            
    def run_tronson_model(self):
        params = {
            "linie_jt_introduse": self.get_layer_path("LINIE_JT"),
            "stalpi_desenati": self.get_layer_path("STALP_JT"),
            "tronson_desenat": self.get_layer_path("TRONSON_JT"),
            "tronson_xml_": QgsProcessing.TEMPORARY_OUTPUT
        }

        try:
            result = processing.run("model:001 TRONSON_JT", params)
            
            scratch_layer = result["tronson_xml_"]

            if isinstance(scratch_layer, QgsVectorLayer):
                scratch_layer.setName("TRONSON_XML_")
                QgsProject.instance().addMapLayer(scratch_layer)
                save_path = os.path.join(self.base_dir, "TRONSON_XML_.gpkg")

                options = QgsVectorFileWriter.SaveVectorOptions()
                options.driverName = "GPKG"  # Saves as a GeoPackage
                options.fileEncoding = "UTF-8"

                error = QgsVectorFileWriter.writeAsVectorFormatV3(scratch_layer, save_path, QgsCoordinateTransformContext(), options)

                if error[0] == QgsVectorFileWriter.NoError:
                    QMessageBox.information(self.iface.mainWindow(), "Success", f"Layer saved successfully at {save_path}")
                else:
                    QMessageBox.critical(self.iface.mainWindow(), "Save Error", f"Failed to save layer: {error}")

            else:
                raise TypeError("Unexpected output type from processing.run")

            QMessageBox.information(self.iface.mainWindow(), "Model Completed", "001 TRONSON_JT model finished successfully!")

        except Exception as e:
            QMessageBox.critical(self.iface.mainWindow(), "Model Error", f"An error occurred: {str(e)}")
            

    def run_brans_model(self):
        """Run Brans model with a progress window."""
        
        params = {
            "brans_firi_desenate": self.get_layer_path("BRANS_FIRI_GRPM_JT"),
            "fb_pe_c_les": self.get_layer_path("FB pe C LES"),
            "linie_jt_introduse": self.get_layer_path("LINIE_JT"),
            "bransament_xml_": QgsProcessing.TEMPORARY_OUTPUT,  # Scratch layer
            "grup_masura_xml_": QgsProcessing.TEMPORARY_OUTPUT,  # Scratch layer
            "firida_xml_": QgsProcessing.TEMPORARY_OUTPUT  # Scratch layer
        }

        try:
            # Run the processing model
            result = processing.run("model:002 BRANS_FIRI_GR", params)

            # Dictionary to store layer names and their permanent save paths
            layers_to_save = {
                "bransament_xml_": "BRANSAMENT_XML_.gpkg",
                "grup_masura_xml_": "GRUP_MASURA_XML_.gpkg",
                "firida_xml_": "FIRIDA_XML_.gpkg"
            }

            for key, filename in layers_to_save.items():
                scratch_layer = result[key]
                if isinstance(scratch_layer, QgsVectorLayer):
                    # Rename and add scratch layer to project
                    scratch_layer.setName(key.upper())  # Ensure consistency with naming
                    QgsProject.instance().addMapLayer(scratch_layer)

                    # Define save path
                    save_path = os.path.join(self.base_dir, filename)

                    # Save a permanent copy
                    options = QgsVectorFileWriter.SaveVectorOptions()
                    options.driverName = "GPKG"  # Saves as a GeoPackage
                    options.fileEncoding = "UTF-8"

                    error = QgsVectorFileWriter.writeAsVectorFormatV3(
                        scratch_layer, save_path, QgsCoordinateTransformContext(), options
                    )

                    if error[0] == QgsVectorFileWriter.NoError:
                        QMessageBox.information(
                            self.iface.mainWindow(), "Success", f"Layer {key} saved successfully at {save_path}"
                        )
                    else:
                        QMessageBox.critical(
                            self.iface.mainWindow(), "Save Error", f"Failed to save layer {key}: {error}"
                        )
                else:
                    raise TypeError(f"Unexpected output type for {key} from processing.run")

            QMessageBox.information(self.iface.mainWindow(), "Model Completed", "002 BRANS_FIRI_GR model finished successfully!")

        except Exception as e:
            QMessageBox.critical(self.iface.mainWindow(), "Model Error", f"An error occurred: {str(e)}")

    def run_stalp_model(self):
        """Run Stalp model with a progress window."""
        
        params = {
            "poze_geotag": self.get_layer_path("poze"),
            "stalp_in_lucru": self.get_layer_path("STALP_JT"),
            "stalp_xml_": QgsProcessing.TEMPORARY_OUTPUT  # Scratch layer
        }
        
        try:
            # Run the processing model
            result = processing.run("model:003 STALP JT generare", params)

            # Retrieve the scratch layer
            scratch_layer = result["stalp_xml_"]

            if isinstance(scratch_layer, QgsVectorLayer):
                # Rename and add scratch layer to project
                scratch_layer.setName("STALP_XML_")
                QgsProject.instance().addMapLayer(scratch_layer)

                # Define save path
                save_path = os.path.join(self.base_dir, "STALP_XML_.gpkg")

                # Save a permanent copy
                options = QgsVectorFileWriter.SaveVectorOptions()
                options.driverName = "GPKG"  # Saves as a GeoPackage
                options.fileEncoding = "UTF-8"

                error = QgsVectorFileWriter.writeAsVectorFormatV3(
                    scratch_layer, save_path, QgsCoordinateTransformContext(), options
                )

                if error[0] == QgsVectorFileWriter.NoError:
                    QMessageBox.information(
                        self.iface.mainWindow(), "Success", f"Layer STALP_XML_ saved successfully at {save_path}"
                    )
                else:
                    QMessageBox.critical(
                        self.iface.mainWindow(), "Save Error", f"Failed to save layer STALP_XML_: {error}"
                    )
            else:
                raise TypeError("Unexpected output type for stalp_xml_ from processing.run")

            QMessageBox.information(self.iface.mainWindow(), "Model Completed", "003 STALP JT model finished successfully!")

        except Exception as e:
            QMessageBox.critical(self.iface.mainWindow(), "Model Error", f"An error occurred: {str(e)}")

    
    def run_deschideri_model(self):
        """Run Deschideri model with a progress window."""
        
        params = {
            "stalpi_desenati": self.get_layer_by_name("STALP_JT"),
            "tronson_jt": self.get_layer_by_name("TRONSON_JT"),
            "deschideri_xml_": QgsProcessing.TEMPORARY_OUTPUT,  # Scratch layer
            "scr_dwg": QgsProcessing.TEMPORARY_OUTPUT  # Scratch layer
        }
        
        try:
            # Run the processing model
            result = processing.run("model:004 DESCHIDERI JT", params)

            # Dictionary to store layers and their corresponding permanent file paths
            layers_to_save = {
                "deschideri_xml_": "DESCHIDERI_XML_.gpkg",
                "scr_dwg": "SCR_DWG.gpkg"
            }

            for key, filename in layers_to_save.items():
                scratch_layer = result[key]
                if isinstance(scratch_layer, QgsVectorLayer):
                    # Rename and add scratch layer to project
                    scratch_layer.setName(key.upper())
                    QgsProject.instance().addMapLayer(scratch_layer)

                    # Define save path
                    save_path = os.path.join(self.base_dir, filename)

                    # Save a permanent copy
                    options = QgsVectorFileWriter.SaveVectorOptions()
                    options.driverName = "GPKG"  # Saves as a GeoPackage
                    options.fileEncoding = "UTF-8"

                    error = QgsVectorFileWriter.writeAsVectorFormatV3(
                        scratch_layer, save_path, QgsCoordinateTransformContext(), options
                    )

                    if error[0] == QgsVectorFileWriter.NoError:
                        QMessageBox.information(
                            self.iface.mainWindow(), "Success", f"Layer {key} saved successfully at {save_path}"
                        )
                    else:
                        QMessageBox.critical(
                            self.iface.mainWindow(), "Save Error", f"Failed to save layer {key}: {error}"
                        )
                else:
                    raise TypeError(f"Unexpected output type for {key} from processing.run")

            # Retrieve the SCR_DWG layer for .scr file export
            scr_dwg_path = os.path.join(self.base_dir, "SCR_DWG.gpkg")
            scr_dwg_layer = QgsVectorLayer(scr_dwg_path, "SCR_DWG", "ogr")
            
            if not scr_dwg_layer.isValid():
                raise Exception("Failed to load the SCR_DWG layer.")

            # Extract SCR_STLP column data
            scr_stlp_data = [feature["SCR_STLP"] for feature in scr_dwg_layer.getFeatures() if "SCR_STLP" in feature]

            # Write to a .scr file in the "temp" subdirectory
            scr_file_path = self.helper.create_valid_output(self.base_dir, "SCR_STLP.scr", "temp")

            with open(scr_file_path, "w") as scr_file:
                for line in scr_stlp_data:
                    scr_file.write(f"{line}\n")

            QMessageBox.information(self.iface.mainWindow(), "Export Completed", f"SCR_STLP data exported to {scr_file_path} successfully!")

        except Exception as e:
            QMessageBox.critical(self.iface.mainWindow(), "Model Error", f"An error occurred: {str(e)}")

    def run_tronsoane_duble_model(self):
        """Run TRONSOANE DUBLE ACTUALIZARE model with a scratch layer and saved copy."""
        
        params = {
            "tronson_aranjat": self.get_layer_by_name("TRONSON_XML_"),
            "tronson_predare_xml": QgsProcessing.TEMPORARY_OUTPUT  # Scratch layer
        }
        
        try:
            # Run the processing model
            result = processing.run("model:TRONSOANE DUBLE ACTUALIZARE", params)

            # Retrieve the scratch layer
            scratch_layer = result["tronson_predare_xml"]

            if isinstance(scratch_layer, QgsVectorLayer):
                # Rename and add scratch layer to project
                scratch_layer.setName("TRONSON_predare_xml")
                QgsProject.instance().addMapLayer(scratch_layer)

                # Define save path
                save_path = os.path.join(self.base_dir, "TRONSON_predare_xml.gpkg")

                # Save a permanent copy
                options = QgsVectorFileWriter.SaveVectorOptions()
                options.driverName = "GPKG"  # Saves as a GeoPackage
                options.fileEncoding = "UTF-8"

                error = QgsVectorFileWriter.writeAsVectorFormatV3(
                    scratch_layer, save_path, QgsCoordinateTransformContext(), options
                )

                if error[0] == QgsVectorFileWriter.NoError:
                    QMessageBox.information(
                        self.iface.mainWindow(), "Success", f"Layer TRONSON_predare_xml saved successfully at {save_path}"
                    )
                else:
                    QMessageBox.critical(
                        self.iface.mainWindow(), "Save Error", f"Failed to save layer TRONSON_predare_xml: {error}"
                    )
            else:
                raise TypeError("Unexpected output type for tronson_predare_xml from processing.run")

            QMessageBox.information(self.iface.mainWindow(), "Model Completed", "TRONSOANE DUBLE ACTUALIZARE model finished successfully!")

        except Exception as e:
            QgsMessageLog.logMessage(f"Error in TRONSOANE DUBLE ACTUALIZARE model: {str(e)}", "StalpiAssist", level=Qgis.Critical)
            QMessageBox.critical(self.iface.mainWindow(), "Model Error", f"An error occurred: {str(e)}")

    def generate_xml(self):
        self.process_layers(self.layers)
        dialog = GenerateXMLDialog(self.base_dir)  # Create an instance of your dialog
        dialog.exec_()  # Properly call exec_ on the instance
        
    def generate_anexa(self):
        self.process_layers(self.layers)
        dialog = GenerateExcelDialog(self.base_dir)  # Create an instance of your dialog
        dialog.exec_()  # Properly call exec_ on the instance
        
    def generare_machete(self):
        try: 
            xls1_params = {
                'linie': self.get_layer_by_name('LINIE_JT'),
                'stalp_xml_': self.get_layer_by_name('STALP_XML_'),
                'tronson_aranjat_': self.get_layer_by_name('TRONSON_predare_xml'),
                'tronson_xml_': self.get_layer_by_name('TRONSON_XML_'),
                'aux_tr': self.helper.create_valid_output(self.base_dir, "AUX_tr.gpkg", "machete"),
                'linie_macheta': self.helper.create_valid_output(self.base_dir, "LINIE_MACHETA.gpkg", "machete"),
                'stalpi_macheta': self.helper.create_valid_output(self.base_dir, "STALPI MACHETA.gpkg", "machete"),
                'tronson_macheta': self.helper.create_valid_output(self.base_dir, "TRONSON MACHETA.gpkg", "machete")
            }

            # Run XLS_1 model
            processing.run('model:005 GENERARE MACHETE XLS_1', xls1_params)

            # Add resulting layers to project
            self.helper.add_layer_to_project(xls1_params['aux_tr'])
            self.helper.add_layer_to_project(xls1_params['linie_macheta'])
            self.helper.add_layer_to_project(xls1_params['stalpi_macheta'])
            self.helper.add_layer_to_project(xls1_params['tronson_macheta'])

        except Exception as e:
            QMessageBox.critical(self.iface.mainWindow(), "XLS_1 Model Error", f"An error occurred: {str(e)}")
            return  # Stop execution if XLS_1 fails

        try:
            xls2_params = {
                'bransament_xml_': self.get_layer_by_name('BRANSAMENT_XML_'),
                'deschideri_xml': self.get_layer_by_name('DESCHIDERI_XML_'),
                'firida_xml_': self.get_layer_by_name('FIRIDA_XML_'),
                'grup_masura_xml_': self.get_layer_by_name('GRUP_MASURA_XML_'),
                'linia_jt': self.get_layer_by_name('LINIE_JT'),
                'firida_macheta': self.helper.create_valid_output(self.base_dir, "FIRIDA MACHETA.gpkg", "machete"),
                'grup_masura_macheta': self.helper.create_valid_output(self.base_dir, "GRUP MASURA MACHETA.gpkg", "machete"),
                'deschideri_macheta': self.helper.create_valid_output(self.base_dir, "DESCHIDERI MACHETA.gpkg", "machete"),
                'bransamente_macheta': self.helper.create_valid_output(self.base_dir, "BRANSAMENTE MACHETA.gpkg", "machete")
            }

            # Run XLS_2 model
            processing.run('model:006 GENERARE MACHETE XLS_2', xls2_params)

            # Add resulting layers to project
            self.helper.add_layer_to_project(xls2_params['firida_macheta'])
            self.helper.add_layer_to_project(xls2_params['grup_masura_macheta'])
            self.helper.add_layer_to_project(xls2_params['deschideri_macheta'])
            self.helper.add_layer_to_project(xls2_params['bransamente_macheta'])

        except Exception as e:
            QMessageBox.critical(self.iface.mainWindow(), "XLS_2 Model Error", f"An error occurred: {str(e)}")
        
        QMessageBox.information(self.iface.mainWindow(), "Model Completed", "Generare Machete models finished successfully!")    
    def process_layers(self, layers):
        if not self.processor:
            try:
                self.processor = SHPProcessor(layers)
            except Exception as e:
                return
        
        try:
            current_layers = self.helper.get_layers()
        except Exception as e:
            return
        
        if current_layers != layers:
            self.processor = None
            
            try:
                self.processor = SHPProcessor(current_layers)
            except Exception as e:
                return
        else:
            return
