# -*- coding: utf-8 -*-
"""
/***************************************************************************
 StalpiAssist
                                 A QGIS plugin
 Helps in assisting for Stalpi
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-11-29
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Ionela
        email                : ioneladumitra@yahoo.ro
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from pathlib import Path

from . import config

import os
import colorsys
import random

from qgis.core import QgsProject, QgsDxfExport, QgsCoordinateTransformContext # type: ignore

from PyQt5.QtGui import QColor # type: ignore
from PyQt5.QtWidgets import QMessageBox, QFileDialog, QAction, QInputDialog # type: ignore 
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, QFile # type: ignore
from qgis.PyQt.QtGui import QIcon  # type: ignore
from qgis.core import ( # type: ignore
    QgsMessageLog,
    QgsProcessingFeedback,
    Qgis,
    QgsProcessingContext,
    QgsProject,
    QgsVectorLayer,
    QgsProcessing,
    QgsGeometry,
    QgsWkbTypes,
    QgsVectorFileWriter,
    QgsCoordinateTransformContext,
    register_function,
    QgsSymbol,
    QgsRendererCategory,
    QgsCategorizedSymbolRenderer,
    QgsPalLayerSettings,
    QgsTextFormat,
    QgsVectorLayerSimpleLabeling,
    QgsTextBufferSettings
)


import processing  # type: ignore

import os
import os.path

from .resources import *

from .func.helper_functions import HelperBase, SHPProcessor

from .func.generate_xml import GenerateXMLDialog
from .func.generate_excel import GenerateExcelDialog
import pandas as pd


class StalpiAssist:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        self.context = QgsProcessingContext()
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        self.helper = HelperBase()
        # self.register_functions()
        self.processor = None
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'StalpiAssist_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&StalpiAssist')
        
        self.layers = self.helper.get_layers()

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None


    @staticmethod
    def plugin_path(*args) -> Path:
        """ Return the path to the plugin root folder or file. """
        path = Path(__file__).resolve().parent
        for item in args:
            path = path.joinpath(item)
        return path


    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('StalpiAssist', message)


    def add_action(
        self,
        name,
        text,
        callback=None,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None,
        icon_path=None,
        shortcut=None,):
        
        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.setEnabled(enabled_flag)

        if callback is not None:
            action.triggered.connect(callback)
            action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)
            
        if shortcut is not None:
            action.setShortcut(shortcut)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action


    def initGui(self):

        self.toolbar = self.iface.addToolBar('StalpiAssist')
        self.toolbar.setObjectName('StalpiAssist')
        self.toolbar.setMovable(True)
        
        # Adding actions with default enabled flag set to False except "Fisier Destinatie"
        self.fisier_destinatie_action = self.add_action(
            "Fisier Destinatie",
            text=self.tr(u'Fisier Destinatie'),
            callback=self.set_base_dir,
            parent=self.iface.mainWindow(),
            icon_path= str(self.plugin_path('icons/folder.png')),
            enabled_flag=True
        )
        
        self.actions_to_enable = [
            self.add_action(
                "Completare câmpuri",
                text=self.tr(u'Completare câmpuri'),
                callback=self.complete_fields,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/0.png')),
                enabled_flag=False
            ),
            self.add_action(
                "001_TRONSON_JT",
                text=self.tr(u'001_TRONSON_JT'),
                callback=self.run_tronson_model,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/1.png')),
                enabled_flag=False
            ),
            self.add_action(
                "002_BRANS_FIRI_GR",
                text=self.tr(u'002_BRANS_FIRI_GR'),
                callback=self.run_brans_model,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/2.png')),
                enabled_flag=False
            ),
            self.add_action(
                "003_STALP_JT",
                text=self.tr(u'003_STALP_JT'),
                callback=self.run_stalp_model,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/3.png')),
                enabled_flag=False
            ),
            self.add_action(
                "004_DESCHIDERI_JT",
                text=self.tr(u'004_DESCHIDERI_JT'),
                callback=self.run_deschideri_model,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/4.png')),
                enabled_flag=False
            ),
            self.add_action(
                "003_TRONSOANE_DUBLE",
                text=self.tr(u'003_TRONSOANE_DUBLE'),
                callback=self.run_tronsoane_duble_model,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/5.png')),
                enabled_flag=False
            ),
            self.add_action(
                "Generare XML",
                text=self.tr(u'Generare XML'),
                callback=self.generate_xml,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/xml.png')),
                enabled_flag=False
            ),
            self.add_action(
                "Generare Machete",
                text=self.tr(u'Generare Machete'),
                callback=self.generare_machete,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/macheta.png')),
                enabled_flag=False
            ),
            self.add_action(
                "Generate Anexa",
                text=self.tr(u'Generate Anexa'),
                callback=self.generate_anexa,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/anexa.png')),
                enabled_flag=False
            ),
            self.add_action(
                "Stilizare Machete",
                text=self.tr(u'Stilizare Machete'),
                callback=self.export_dxf_kml,
                parent=self.iface.mainWindow(),
                icon_path= str(self.plugin_path('icons/export.png')),
                enabled_flag=False
            )
        ]
        
        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(self.tr(u'&Stalpi Assist'), action)
            self.toolbar.removeAction(action)
        del self.toolbar
        
    def register_functions(self):
        def round_wkt_coordinates(values, feature=None, parent=None, context=None):
            def format_point(point):
                return f"{round(point.x(), 4):.4f} {round(point.y(), 4):.4f}"

            geometry = values[0]  # Get the geometry from the input
            if isinstance(geometry, QgsGeometry):
                if geometry.isMultipart():
                    if geometry.type() == QgsWkbTypes.LineGeometry:
                        parts = [
                            "(" + ", ".join(format_point(point) for point in line) + ")"
                            for line in geometry.asMultiPolyline()
                        ]
                        wkt = f"MULTILINESTRING ({', '.join(parts)})"
                    else:
                        wkt = geometry.asWkt()  # For other geometry types
                else:
                    if geometry.type() == QgsWkbTypes.LineGeometry:
                        points = ", ".join(format_point(point) for point in geometry.asPolyline())
                        wkt = f"LINESTRING ({points})"
                    else:
                        wkt = geometry.asWkt()  # For other geometry types
                return wkt
            return None  # Return None if input is invalid

        register_function(
            round_wkt_coordinates,
            group="Custom",
            usesgeometry=True,
            params_as_list=True,
            helpText="Rounds WKT geometry coordinates to a given precision."
        )
        
    def get_layer_path(self, layer_name):
        """
        Get the full data source path of a layer by its name.

        Parameters:
            layer_name (str): The name of the layer in the QGIS project.

        Returns:
            str: The full data source path of the layer, including `|layername=`.
                Returns None if the layer is not found.
        """
        # Search for the layer by name in the current project
        layers = QgsProject.instance().mapLayersByName(layer_name)
        if not layers:
            QgsMessageLog.logMessage(f"Layer '{layer_name}' not found in the project.", "StalpiAssist", level=Qgis.Warning)
            return None
        
        # Get the first matching layer
        layer = layers[0]
        # Extract the data source path
        data_source = layer.dataProvider().dataSourceUri()
        
        # Append layername (important for GPKG files with multiple layers)
        if layer.storageType() == "GeoPackage" and "|layername=" not in data_source:
            data_source += f"|layername={layer.name()}"
        
        return data_source
    
    def get_layer_by_name(self, layer_name):
        """Retrieve a layer from the QGIS project by name."""
        layer = QgsProject.instance().mapLayersByName(layer_name)
        if layer:
            return layer[0]  # Return the first matching layer
        else:
            raise Exception(f"Layer '{layer_name}' not found in the project.")
    
    def set_base_dir(self):
        """Set base directory and update icons."""
        base_dir = QFileDialog.getExistingDirectory(None, "Select Base Directory", "")
        if base_dir:
            self.base_dir = base_dir
            
            self.fisier_destinatie_action.setIcon(QIcon(str(self.plugin_path('icons/complete.png'))))
            
            for action in self.actions_to_enable:
                action.setEnabled(True)
                
            self.feedback = QgsProcessingFeedback()
            self.context.setProject(QgsProject.instance())
            
            existing_layer = QgsProject.instance().mapLayersByName("GRID_GEOID")
            
            if not existing_layer:
                template_file = self.plugin_path('func', 'templates', 'GRID_GEOID.gpkg')
                layer = QgsVectorLayer(f"{template_file}|layername=GRID_GEOID", "GRID_GEOID", "ogr")
                
                if layer.isValid():
                    QgsProject.instance().addMapLayer(layer)
                    
                    root = QgsProject.instance().layerTreeRoot()
                    layer_node = root.findLayer(layer.id())
                    if layer_node:
                        layer_node.setItemVisibilityChecked(False)
                else:
                    QgsMessageLog.logMessage("Failed to load GRID_GEOID layer.", "StalpiAssist", level=Qgis.Critical)

    def complete_fields(self):
        '''
        - Complete @row_number field in NR_CRT for - STALP_JT, TRONSON_JT, BRANS_FIRI_GRMP_JT
        - Ask user for Denumire
        - Add in QGIS table from templates: bd.xlsx and search by Descrierea BDI == Denumire
        - In layer TRONSON_JT - UNIT_LOG_INT - complete with the value from 'Unitatea logistica de intretinere'
        - In layer TRONSON_JT - S_UNIT_LOG - complete with the value from 'Sectie unitate logistica'
        - In layer TRONSON_JT - POST_LUC - complete with the value from 'Post de lucru'
        
        - In layer STALP_JT - DESC_DET - complete with the value from column f'{"Sucursala"}-{"Post de lucru"}'
        '''

        # Get active QGIS project
        project = QgsProject.instance()

        # Prompt user for 'Denumire'
        denumire, ok = QInputDialog.getText(None, "Input Descriere BDI", "Introduce Descrierea BDI:")
        if not ok or not denumire:
            return
        
        # Load the Excel template
        xlsx_path = self.plugin_path('func', 'templates', 'bd.xlsx')
        df = pd.read_excel(xlsx_path)
        
        # Search for the row where 'Descrierea BDI' == Denumire
        match = df[df['Descrierea BDI'] == denumire]
        if match.empty:
            QgsMessageLog.logMessage(f"No matching entry for {denumire} in bd.xlsx", "StalpiAssist", level=Qgis.Warning)
            return
        
        # Extract relevant values
        unit_log_int = match.iloc[0]['Unitate logistica de întretinere']
        s_unit_log = match.iloc[0]['Sectie unitate logistica']
        post_luc = match.iloc[0]['Post de lucru']
        sucursala = match.iloc[0]['Sucursala']

        # Assign NR_CRT based on row number
        def assign_row_numbers(layer):
            """Assigns sequential row numbers to NR_CRT."""
            layer.startEditing()
            for index, feat in enumerate(layer.getFeatures(), start=1):
                feat["NR_CRT"] = index  # Assign row number
                layer.updateFeature(feat)
            layer.commitChanges()

        # Update TRONSON_JT
        tronson_layer = project.mapLayersByName("TRONSON_JT")[0]
        if tronson_layer:
            tronson_layer.startEditing()
            for feat in tronson_layer.getFeatures():
                feat["UNIT_LOG_INT"] = unit_log_int
                feat["S_UNIT_LOG"] = s_unit_log
                feat["POST_LUC"] = post_luc
                tronson_layer.updateFeature(feat)
            tronson_layer.commitChanges()
            assign_row_numbers(tronson_layer)  # Assign row numbers after updating

        # Update STALP_JT
        stalp_layer = project.mapLayersByName("STALP_JT")[0]
        if stalp_layer:
            stalp_layer.startEditing()
            for feat in stalp_layer.getFeatures():
                feat["DESC_DET"] = f"{sucursala}-{post_luc}"
                stalp_layer.updateFeature(feat)
            stalp_layer.commitChanges()
            assign_row_numbers(stalp_layer)  # Assign row numbers after updating

        # Update BRANS_FIRI_GRMP_JT
        brans_layer = project.mapLayersByName("BRANS_FIRI_GRPM_JT")[0]
        if brans_layer:
            assign_row_numbers(brans_layer)  # Directly assign row numbers

        QMessageBox.information(None, "Success", "Fields completed successfully!")



    def run_tronson_model(self):
        params = {
            "linie_jt_introduse": self.get_layer_path("LINIE_JT"),
            "stalpi_desenati": self.get_layer_path("STALP_JT"),
            "tronson_desenat": self.get_layer_path("TRONSON_JT"),
            "tronson_xml_": QgsProcessing.TEMPORARY_OUTPUT
        }

        try:
            result = processing.run("model:001 TRONSON_JT", params)
            
            scratch_layer = result["tronson_xml_"]

            if isinstance(scratch_layer, QgsVectorLayer):
                # Save TRONSON_XML_
                scratch_layer.setName("TRONSON_XML_")
                QgsProject.instance().addMapLayer(scratch_layer)
                save_path = os.path.join(self.base_dir, "TRONSON_XML_.gpkg")

                options = QgsVectorFileWriter.SaveVectorOptions()
                options.driverName = "GPKG"
                options.fileEncoding = "UTF-8"

                error = QgsVectorFileWriter.writeAsVectorFormatV3(
                    scratch_layer, save_path, QgsCoordinateTransformContext(), options
                )

                if error[0] == QgsVectorFileWriter.NoError:
                    QMessageBox.information(self.iface.mainWindow(), "Success", f"Layer saved successfully at {save_path}")
                else:
                    QMessageBox.critical(self.iface.mainWindow(), "Save Error", f"Failed to save layer: {error}")

                # Duplicate the output layer as NO_OFFSET_TRONSON_XML_
                no_offset_layer = scratch_layer.clone()
                no_offset_layer.setName("NO_OFFSET_TRONSON_XML_")
                QgsProject.instance().addMapLayer(no_offset_layer)

                # Apply categorization by "ID_LOC" only to TRONSON_XML_
                field_name = "ID_LOC"
                unique_values = scratch_layer.uniqueValues(scratch_layer.fields().lookupField(field_name))
                categories = []
                
                predefined_colors = [
                    QColor(255, 0, 0), QColor(0, 255, 0), QColor(0, 0, 255),
                    QColor(255, 255, 0), QColor(255, 165, 0), QColor(255, 20, 147),
                    QColor(0, 255, 255), QColor(128, 0, 128), QColor(0, 128, 0),
                    QColor(0, 0, 128), QColor(75, 0, 130), QColor(255, 105, 180)
                ]
                random.shuffle(predefined_colors)
                
                for i, value in enumerate(unique_values):
                    if i >= len(predefined_colors):
                        break
                    symbol = QgsSymbol.defaultSymbol(scratch_layer.geometryType())
                    symbol.setColor(predefined_colors[i])
                    symbol.setWidth(1.25)
                    categories.append(QgsRendererCategory(value, symbol, str(value)))
                
                renderer = QgsCategorizedSymbolRenderer(field_name, categories)
                scratch_layer.setRenderer(renderer)
                scratch_layer.triggerRepaint()

            else:
                raise TypeError("Unexpected output type from processing.run")

            QMessageBox.information(self.iface.mainWindow(), "Model Completed", "001 TRONSON_JT model finished successfully!")

        except Exception as e:
            QMessageBox.critical(self.iface.mainWindow(), "Model Error", f"An error occurred: {str(e)}")

            

    def run_brans_model(self):
        """Run Brans model with a progress window."""
        
        params = {
            "brans_firi_desenate": self.get_layer_path("BRANS_FIRI_GRPM_JT"),
            "fb_pe_c_les": self.get_layer_path("FB pe C LES"),
            "linie_jt_introduse": self.get_layer_path("LINIE_JT"),
            "bransament_xml_": QgsProcessing.TEMPORARY_OUTPUT,  # Scratch layer
            "grup_masura_xml_": QgsProcessing.TEMPORARY_OUTPUT,  # Scratch layer
            "firida_xml_": QgsProcessing.TEMPORARY_OUTPUT  # Scratch layer
        }

        try:
            # Run the processing model
            result = processing.run("model:002 BRANS_FIRI_GR", params)

            # Dictionary to store layer names and their permanent save paths
            layers_to_save = {
                "bransament_xml_": "BRANSAMENT_XML_.gpkg",
                "grup_masura_xml_": "GRUP_MASURA_XML_.gpkg",
                "firida_xml_": "FIRIDA_XML_.gpkg"
            }

            for key, filename in layers_to_save.items():
                scratch_layer = result[key]
                if isinstance(scratch_layer, QgsVectorLayer):
                    # Rename and add scratch layer to project
                    scratch_layer.setName(key.upper())  # Ensure consistency with naming
                    QgsProject.instance().addMapLayer(scratch_layer)

                    # Define save path
                    save_path = os.path.join(self.base_dir, filename)

                    # Save a permanent copy
                    options = QgsVectorFileWriter.SaveVectorOptions()
                    options.driverName = "GPKG"  # Saves as a GeoPackage
                    options.fileEncoding = "UTF-8"

                    error = QgsVectorFileWriter.writeAsVectorFormatV3(
                        scratch_layer, save_path, QgsCoordinateTransformContext(), options
                    )

                    if error[0] == QgsVectorFileWriter.NoError:
                        QMessageBox.information(
                            self.iface.mainWindow(), "Success", f"Layer {key} saved successfully at {save_path}"
                        )
                    else:
                        QMessageBox.critical(
                            self.iface.mainWindow(), "Save Error", f"Failed to save layer {key}: {error}"
                        )
                else:
                    raise TypeError(f"Unexpected output type for {key} from processing.run")

            QMessageBox.information(self.iface.mainWindow(), "Model Completed", "002 BRANS_FIRI_GR model finished successfully!")

        except Exception as e:
            QMessageBox.critical(self.iface.mainWindow(), "Model Error", f"An error occurred: {str(e)}")

    def run_stalp_model(self):
        """Run Stalp model with a progress window."""
        
        params = {
            "poze_geotag": self.get_layer_path("poze"),
            "stalp_in_lucru": self.get_layer_path("STALP_JT"),
            "stalp_xml_": QgsProcessing.TEMPORARY_OUTPUT  # Scratch layer
        }
        
        try:
            # Run the processing model
            result = processing.run("model:003 STALP JT generare", params)

            # Retrieve the scratch layer
            scratch_layer = result["stalp_xml_"]

            if isinstance(scratch_layer, QgsVectorLayer):
                # Rename and add scratch layer to project
                scratch_layer.setName("STALP_XML_")
                QgsProject.instance().addMapLayer(scratch_layer)

                # Define save path
                save_path = os.path.join(self.base_dir, "STALP_XML_.gpkg")

                # Save a permanent copy
                options = QgsVectorFileWriter.SaveVectorOptions()
                options.driverName = "GPKG"  # Saves as a GeoPackage
                options.fileEncoding = "UTF-8"

                error = QgsVectorFileWriter.writeAsVectorFormatV3(
                    scratch_layer, save_path, QgsCoordinateTransformContext(), options
                )

                if error[0] == QgsVectorFileWriter.NoError:
                    QMessageBox.information(
                        self.iface.mainWindow(), "Success", f"Layer STALP_XML_ saved successfully at {save_path}"
                    )
                else:
                    QMessageBox.critical(
                        self.iface.mainWindow(), "Save Error", f"Failed to save layer STALP_XML_: {error}"
                    )
            else:
                raise TypeError("Unexpected output type for stalp_xml_ from processing.run")

            QMessageBox.information(self.iface.mainWindow(), "Model Completed", "003 STALP JT model finished successfully!")

        except Exception as e:
            QMessageBox.critical(self.iface.mainWindow(), "Model Error", f"An error occurred: {str(e)}")

    
    def run_deschideri_model(self):
        """Run Deschideri model with a progress window."""
        
        params = {
            "stalpi_desenati": self.get_layer_by_name("STALP_JT"),
            "tronson_jt": self.get_layer_by_name("TRONSON_JT"),
            "deschideri_xml_": QgsProcessing.TEMPORARY_OUTPUT,  # Scratch layer
            "scr_dwg": QgsProcessing.TEMPORARY_OUTPUT  # Scratch layer
        }
        
        try:
            # Run the processing model
            result = processing.run("model:004 DESCHIDERI JT", params)

            # Dictionary to store layers and their corresponding permanent file paths
            layers_to_save = {
                "deschideri_xml_": "DESCHIDERI_XML_.gpkg",
                "scr_dwg": "SCR_DWG.gpkg"
            }

            for key, filename in layers_to_save.items():
                scratch_layer = result[key]
                if isinstance(scratch_layer, QgsVectorLayer):
                    # Rename and add scratch layer to project
                    scratch_layer.setName(key.upper())
                    QgsProject.instance().addMapLayer(scratch_layer)

                    # Define save path
                    save_path = os.path.join(self.base_dir, filename)

                    # Save a permanent copy
                    options = QgsVectorFileWriter.SaveVectorOptions()
                    options.driverName = "GPKG"  # Saves as a GeoPackage
                    options.fileEncoding = "UTF-8"

                    error = QgsVectorFileWriter.writeAsVectorFormatV3(
                        scratch_layer, save_path, QgsCoordinateTransformContext(), options
                    )

                    if error[0] == QgsVectorFileWriter.NoError:
                        QMessageBox.information(
                            self.iface.mainWindow(), "Success", f"Layer {key} saved successfully at {save_path}"
                        )
                    else:
                        QMessageBox.critical(
                            self.iface.mainWindow(), "Save Error", f"Failed to save layer {key}: {error}"
                        )
                else:
                    raise TypeError(f"Unexpected output type for {key} from processing.run")
                
        except Exception as e:
            QMessageBox.critical(self.iface.mainWindow(), "Model Error", f"An error occurred: {str(e)}")

        # Retrieve the SCR_DWG layer for .scr file export
        scr_dwg_layer = QgsProject.instance().mapLayersByName("SCR_DWG")[0]
        
        if not scr_dwg_layer.isValid():
            raise Exception("Failed to load the SCR_DWG layer.")
        
        # Extract SCR_STLP column data
        scr_stlp_data = [
            feature["SCR_STLP"] for feature in scr_dwg_layer.getFeatures() 
            if feature.isValid() and feature["SCR_STLP"] not in config.NULL_VALUES
]
        # Write to a .scr file in the "temp" subdirectory
        scr_file_path = self.helper.create_valid_output(self.base_dir, "SCR_STLP.scr", "temp")

        with open(scr_file_path, "w") as scr_file:
            scr_file.write("\n".join(scr_stlp_data))  # Join with newline without extra at the end

        QMessageBox.information(self.iface.mainWindow(), "Export Completed", f"SCR_STLP data exported to {scr_file_path} successfully!")

    def run_tronsoane_duble_model(self):
        """Run TRONSOANE DUBLE ACTUALIZARE model with a scratch layer and saved copy."""
        
        params = {
            "tronson_aranjat": self.get_layer_by_name("TRONSON_XML_"),
            "tronson_predare_xml": QgsProcessing.TEMPORARY_OUTPUT  # Scratch layer
        }
        
        try:
            # Run the processing model
            result = processing.run("model:TRONSOANE DUBLE ACTUALIZARE", params)

            # Retrieve the scratch layer
            scratch_layer = result["tronson_predare_xml"]

            if isinstance(scratch_layer, QgsVectorLayer):
                # Rename and add scratch layer to project
                scratch_layer.setName("TRONSON_predare_xml")
                QgsProject.instance().addMapLayer(scratch_layer)

                # Define save path
                save_path = os.path.join(self.base_dir, "TRONSON_predare_xml.gpkg")

                # Save a permanent copy
                options = QgsVectorFileWriter.SaveVectorOptions()
                options.driverName = "GPKG"  # Saves as a GeoPackage
                options.fileEncoding = "UTF-8"

                error = QgsVectorFileWriter.writeAsVectorFormatV3(
                    scratch_layer, save_path, QgsCoordinateTransformContext(), options
                )

                if error[0] == QgsVectorFileWriter.NoError:
                    QMessageBox.information(
                        self.iface.mainWindow(), "Success", f"Layer TRONSON_predare_xml saved successfully at {save_path}"
                    )
                else:
                    QMessageBox.critical(
                        self.iface.mainWindow(), "Save Error", f"Failed to save layer TRONSON_predare_xml: {error}"
                    )
            else:
                raise TypeError("Unexpected output type for tronson_predare_xml from processing.run")

            QMessageBox.information(self.iface.mainWindow(), "Model Completed", "TRONSOANE DUBLE ACTUALIZARE model finished successfully!")

        except Exception as e:
            QgsMessageLog.logMessage(f"Error in TRONSOANE DUBLE ACTUALIZARE model: {str(e)}", "StalpiAssist", level=Qgis.Critical)
            QMessageBox.critical(self.iface.mainWindow(), "Model Error", f"An error occurred: {str(e)}")

    def generate_xml(self):
        self.process_layers(self.layers)
        dialog = GenerateXMLDialog(self.base_dir)  # Create an instance of your dialog
        dialog.exec_()  # Properly call exec_ on the instance
        
    def generate_anexa(self):
        self.process_layers(self.layers)
        dialog = GenerateExcelDialog(self.base_dir)  # Create an instance of your dialog
        dialog.exec_()  # Properly call exec_ on the instance
        
    def generare_machete(self):
        try: 
            xls1_params = {
                'linie': self.get_layer_by_name('LINIE_JT'),
                'stalp_xml_': self.get_layer_by_name('STALP_XML_'),
                'tronson_aranjat_': self.get_layer_by_name('TRONSON_predare_xml'),
                'tronson_xml_': self.get_layer_by_name('TRONSON_XML_'),
                'tronson_before_offset': self.get_layer_by_name('NO_OFFSET_TRONSON_XML_'),
                'aux_tr': self.helper.create_valid_output(self.base_dir, "AUX_tr.gpkg", "machete"),
                'linie_macheta': self.helper.create_valid_output(self.base_dir, "LINIE_MACHETA.gpkg", "machete"),
                'stalpi_macheta': self.helper.create_valid_output(self.base_dir, "STALPI MACHETA.gpkg", "machete"),
                'tronson_macheta': self.helper.create_valid_output(self.base_dir, "TRONSON MACHETA.gpkg", "machete")
            }

            # Run XLS_1 model
            processing.run('model:005 GENERARE MACHETE XLS_1', xls1_params)

            # Add resulting layers to project
            self.helper.add_layer_to_project(xls1_params['aux_tr'])
            self.helper.add_layer_to_project(xls1_params['linie_macheta'])
            self.helper.add_layer_to_project(xls1_params['stalpi_macheta'])
            self.helper.add_layer_to_project(xls1_params['tronson_macheta'])

        except Exception as e:
            QMessageBox.critical(self.iface.mainWindow(), "XLS_1 Model Error", f"An error occurred: {str(e)}")
            return  # Stop execution if XLS_1 fails

        try:
            xls2_params = {
                'bransament_xml_': self.get_layer_by_name('BRANSAMENT_XML_'),
                'deschideri_xml': self.get_layer_by_name('DESCHIDERI_XML_'),
                'firida_xml_': self.get_layer_by_name('FIRIDA_XML_'),
                'grup_masura_xml_': self.get_layer_by_name('GRUP_MASURA_XML_'),
                'linia_jt': self.get_layer_by_name('LINIE_JT'),
                'firida_macheta': self.helper.create_valid_output(self.base_dir, "FIRIDA MACHETA.gpkg", "machete"),
                'grup_masura_macheta': self.helper.create_valid_output(self.base_dir, "GRUP MASURA MACHETA.gpkg", "machete"),
                'deschideri_macheta': self.helper.create_valid_output(self.base_dir, "DESCHIDERI MACHETA.gpkg", "machete"),
                'bransamente_macheta': self.helper.create_valid_output(self.base_dir, "BRANSAMENTE MACHETA.gpkg", "machete")
            }

            # Run XLS_2 model
            processing.run('model:006 GENERARE MACHETE XLS_2', xls2_params)

            # Add resulting layers to project
            self.helper.add_layer_to_project(xls2_params['firida_macheta'])
            self.helper.add_layer_to_project(xls2_params['grup_masura_macheta'])
            self.helper.add_layer_to_project(xls2_params['deschideri_macheta'])
            self.helper.add_layer_to_project(xls2_params['bransamente_macheta'])

        except Exception as e:
            QMessageBox.critical(self.iface.mainWindow(), "XLS_2 Model Error", f"An error occurred: {str(e)}")
        
        QMessageBox.information(self.iface.mainWindow(), "Model Completed", "Generare Machete models finished successfully!")    
        
    def process_layers(self, layers):
        if not self.processor:
            try:
                self.processor = SHPProcessor(layers)
            except Exception as e:
                return
        
        try:
            current_layers = self.helper.get_layers()
        except Exception as e:
            return
        
        if current_layers != layers:
            self.processor = None
            
            try:
                self.processor = SHPProcessor(current_layers)
            except Exception as e:
                return
        else:
            return
        
    def export_dxf_kml(self):
        self.stylize_layers()
    
    
    def stylize_layers(self):
        layers = [
            "FIRIDA MACHETA", "BRANSAMENTE MACHETA", "STALPI MACHETA", "TRONSON MACHETA"
        ]
        
        bright_colors = [
            "#FF0000", "#00FF00", "#0000FF", "#FFFF00", "#FF00FF", "#00FFFF",
            "#FFA500", "#8A2BE2", "#DC143C", "#32CD32"
        ]
        
        if len(layers) > len(bright_colors):
            
            bright_colors = [
                "#%02x%02x%02x" % (
                    int(255 * r), int(255 * g), int(255 * b)
                )
                for r, g, b in [colorsys.hsv_to_rgb(i / len(layers), 1, 1) for i in range(len(layers))]
            ]
        
        unique_colors = random.sample(bright_colors, len(layers))  # Pick unique colors
        
        project = QgsProject.instance()
        
        for i, layer_name in enumerate(layers):
            layer = project.mapLayersByName(layer_name)
            if not layer:
                print(f"Layer '{layer_name}' not found!")
                continue
            
            layer = layer[0]
            color = QColor(unique_colors[i])  # Use unique color
            
            settings = QgsPalLayerSettings()
            settings.fieldName = "Descrierea BDI"
            settings.enabled = True
            
            text_format = QgsTextFormat()
            text_format.setSize(50)
            text_format.setColor(color)
            
            buffer = QgsTextBufferSettings()
            buffer.setEnabled(True)
            buffer.setSize(1)
            buffer.setColor(QColor("black"))
            text_format.setBuffer(buffer)
            
            settings.setFormat(text_format)
            
            # Ensure proper labeling behavior for lines
            if layer.geometryType() == QgsWkbTypes.LineGeometry:
                settings.placement = QgsPalLayerSettings.Curved
                settings.isObstacle = False  # Prevents obstacles for labels
            
            labeling = QgsVectorLayerSimpleLabeling(settings)
            layer.setLabeling(labeling)
            layer.setLabelsEnabled(True)
            
            layer.setCustomProperty("labeling", "pal")
            project.layerTreeRoot().findLayer(layer.id()).setCustomProperty("labeling", "pal")
            
            layer.triggerRepaint()
            print(f"Updated layer: {layer_name} with label color {unique_colors[i]}")

        # Force map refresh
        self.iface.mapCanvas().refreshAllLayers()
        QMessageBox.information(self.iface.mainWindow(), "Layer Styling", "Layers styled successfully!")


    def export_to_dxf(self):
        layer_names = ["FIRIDA MACHETA", "BRANSAMENTE MACHETA", "STALPI MACHETA", "TRONSON MACHETA"]
        output_path = os.path.join(self.base_dir, "export.dxf")
        
        project = QgsProject.instance()
        layers = [project.mapLayersByName(name)[0] for name in layer_names]
        
        # Initialize DXF export
        dxf_export = QgsDxfExport()
        dxf_export.setMapLayers(layers)
        dxf_export.setSymbologyExport(True)  # Preserve symbology
        dxf_export.setExportLabelsAs('Text')  # Export labels as TEXT entities
        dxf_export.setLayerTitleAsName(True)  # Use layer titles as names in DXF
        dxf_export.setForce2d(True)  # Ensure geometries are 2D
        
        # Coordinate transformation context
        transform_context = QgsCoordinateTransformContext()
        
        # Export to DXF
        error = dxf_export.writeToFile(output_path, transform_context)
        if error == QgsDxfExport.NoError:
            print(f"DXF export successful: {output_path}")
        else:
            print(f"DXF export failed with error code: {error}")

    def export_kml(self):
        output_directory = self.base_dir
        layers_to_export = [
            "FIRIDA MACHETA", "BRANSAMENTE MACHETA", "STALPI MACHETA", "TRONSON MACHETA"
        ]
        
        # Define colors for layers
        colors = [QColor("red"), QColor("blue"), QColor("green"), QColor("orange"), QColor("purple"), QColor("pink"), QColor("yellow")]
        
        project = QgsProject.instance()
        
        # Export each layer separately as KML
        for i, layer_name in enumerate(layers_to_export):
            layer = project.mapLayersByName(layer_name)
            if not layer:
                QgsMessageLog.logMessage(f"Layer '{layer_name}' not found in the project.", "StalpiAssist", level=Qgis.Critical)
            layer = layer[0]
            
            # Export to KML with name field "Descrierea BDI"
            kml_filename = os.path.join(output_directory, f"{layer_name}.kml")
            options = QgsVectorFileWriter.SaveVectorOptions()
            options.driverName = "KML"
            options.fileEncoding = "utf-8"
            options.onlySelectedFeatures = False
            options.layerName = layer_name
            options.kmlNameField = "Descrierea BDI"
            transform_context = QgsProject.instance().transformContext()
            error = QgsVectorFileWriter.writeAsVectorFormatV3(layer, kml_filename, transform_context, options)
            if error[0] == QgsVectorFileWriter.NoError:
                QMessageBox.information(self.iface.mainWindow(), "KMZ Export", f"{layer_name} exported successfully as KML.")
            else:
                QMessageBox.critical(self.iface.mainWindow(), "KMZ Export", f"Failed to export {layer_name} as KML: {error}")
        
        # Modify KML files for styling
        for kml_file in os.listdir(output_directory):
            if kml_file.endswith(".kml"):
                kml_path = os.path.join(output_directory, kml_file)
                with open(kml_path, "r", encoding="utf-8") as file:
                    kml_content = file.read()
                
                # Modify text size and color
                text_size = "<LabelStyle><scale>2</scale></LabelStyle>"
                color_tag = f"<color>{colors[i % len(colors)].name()}</color>"
                
                kml_content = kml_content.replace("<LabelStyle>", text_size).replace("<IconStyle>", f"<IconStyle>{color_tag}")
                
                # Special pin for "STP. 0" in "STALPI MACHETA"
                if "STALPI MACHETA" in kml_file:
                    kml_content = kml_content.replace("STP. 0", "<Style><IconStyle><scale>1.5</scale></IconStyle></Style>")
                
                with open(kml_path, "w", encoding="utf-8") as file:
                    file.write(kml_content)
                    
        kmz_filename = os.path.join(output_directory, "merged_export.kmz")
        os.system(f"zip -j {kmz_filename} {output_directory}/*.kml")
        QMessageBox.information(self.iface.mainWindow(), "KMZ Export", f"KMZ file exported successfully at {kmz_filename}")
